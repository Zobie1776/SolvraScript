//==============================================
// File: solvra_script/ir/display.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Pretty-print SolvraIR for debugging
// Objective: Provide formatter utilities used by CLI and devtools
//==============================================

use crate::ir::block::BasicBlock;
use crate::ir::function::FunctionIR;
use crate::ir::ops::{Instruction, TerminatorKind};
use std::fmt;

pub struct IrFormatter<'a> {
    function: &'a FunctionIR,
}

impl<'a> IrFormatter<'a> {
    pub fn new(function: &'a FunctionIR) -> Self {
        Self { function }
    }
}

impl<'a> fmt::Display for IrFormatter<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "fn {}(", self.function.name)?;
        for (index, param) in self.function.parameters().iter().enumerate() {
            let value = &self.function.values()[param.index()];
            writeln!(f, "    %arg{}: {}", index, value.ty)?;
        }
        writeln!(f, ") -> {}", self.function.signature.result)?;
        for block in &self.function.blocks {
            render_block(block, self.function, f)?;
        }
        Ok(())
    }
}

fn render_block(
    block: &BasicBlock,
    function: &FunctionIR,
    f: &mut fmt::Formatter<'_>,
) -> fmt::Result {
    writeln!(
        f,
        "{}:",
        block
            .name
            .as_deref()
            .unwrap_or(&format!("bb{}", block.id.index()))
    )?;
    for instruction in &block.instructions {
        render_instruction(instruction, function, f)?;
    }
    if let Some(terminator) = &block.terminator {
        match &terminator.kind {
            TerminatorKind::Return { value } => {
                if let Some(value) = value {
                    writeln!(f, "    ret {}", value)?;
                } else {
                    writeln!(f, "    ret")?;
                }
            }
            TerminatorKind::Jump { target } => {
                writeln!(f, "    jump {}", target)?;
            }
            TerminatorKind::Branch {
                condition,
                then_block,
                else_block,
            } => {
                writeln!(f, "    br {}, {}, {}", condition, then_block, else_block)?;
            }
        }
    }
    Ok(())
}

fn render_instruction(
    instruction: &Instruction,
    function: &FunctionIR,
    f: &mut fmt::Formatter<'_>,
) -> fmt::Result {
    if let Some(result) = instruction.result {
        write!(f, "    {} = ", result)?;
    } else {
        write!(f, "    ")?;
    }
    write!(f, "{:?}", instruction.opcode)?;
    if !instruction.operands.is_empty() {
        let mut first = true;
        write!(f, " ")?;
        for operand in &instruction.operands {
            if !first {
                write!(f, ", ")?;
            }
            let value = &function.values()[operand.index()];
            write!(f, "{}:{}", operand, value.ty)?;
            first = false;
        }
    }
    writeln!(f)?;
    Ok(())
}

impl FunctionIR {
    pub fn dump(&self) -> String {
        format!("{}", IrFormatter::new(self))
    }
}

//==============================================
// End of file
//==============================================
