//==============================================
// File: solvra_script/ir/interpreter.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Execute SolvraIR functions for correctness testing
// Objective: Provide a lightweight interpreter used by the CLI IR mode
//==============================================

use crate::ir::block::BlockId;
use crate::ir::function::{CallTarget, FunctionIR, FunctionId};
use crate::ir::ir::SolvraIrModule;
use crate::ir::ops::{GuardKind, IrOpcode, TerminatorKind};
use crate::ir::value::{ConstantValue, ValueId, ValueKind};
use solvra_core::jit::execute_tier0::Tier0Module;
use solvra_core::jit::tier0_codegen::Tier0FunctionId;
use std::cell::RefCell;
use std::collections::HashMap;
use std::fmt;
use std::io::{self, Write};
use std::rc::Rc;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum IrInterpreterError {
    #[error("function `{0}` not found")]
    UnknownFunction(String),
    #[error("value {0} not available at runtime")]
    MissingValue(ValueId),
    #[error("invalid operand type for {0}")]
    OperandType(&'static str),
    #[error("unsupported opcode {0}")]
    UnsupportedOpcode(&'static str),
    #[error("branch condition is not boolean")]
    BranchCondition,
    #[error("runtime error: {0}")]
    Runtime(String),
    #[error("execution diverged without return")]
    MissingReturn,
}

/// Simple runtime value domain for SolvraIR interpreter.
#[derive(Clone, Debug)]
pub enum RuntimeValue {
    Int(i64),
    Float(f64),
    Bool(bool),
    String(String),
    Array(Rc<RefCell<Vec<RuntimeValue>>>),
    Object(Rc<RefCell<HashMap<String, RuntimeValue>>>),
    Function(FunctionId),
    Null,
}

impl PartialEq for RuntimeValue {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (RuntimeValue::Int(a), RuntimeValue::Int(b)) => a == b,
            (RuntimeValue::Float(a), RuntimeValue::Float(b)) => a == b,
            (RuntimeValue::Bool(a), RuntimeValue::Bool(b)) => a == b,
            (RuntimeValue::String(a), RuntimeValue::String(b)) => a == b,
            (RuntimeValue::Array(a), RuntimeValue::Array(b)) => Rc::ptr_eq(a, b),
            (RuntimeValue::Object(a), RuntimeValue::Object(b)) => Rc::ptr_eq(a, b),
            (RuntimeValue::Function(a), RuntimeValue::Function(b)) => a == b,
            (RuntimeValue::Null, RuntimeValue::Null) => true,
            _ => false,
        }
    }
}

impl RuntimeValue {
    fn as_f64(&self) -> Option<f64> {
        match self {
            RuntimeValue::Int(v) => Some(*v as f64),
            RuntimeValue::Float(v) => Some(*v),
            _ => None,
        }
    }

    fn as_bool(&self) -> Option<bool> {
        match self {
            RuntimeValue::Bool(v) => Some(*v),
            RuntimeValue::Int(v) => Some(*v != 0),
            RuntimeValue::Float(v) => Some(*v != 0.0),
            RuntimeValue::String(v) => Some(!v.is_empty()),
            RuntimeValue::Array(v) => Some(!v.borrow().is_empty()),
            RuntimeValue::Object(v) => Some(!v.borrow().is_empty()),
            RuntimeValue::Null => Some(false),
            RuntimeValue::Function(_) => Some(true),
        }
    }

    fn as_int(&self) -> Option<i64> {
        match self {
            RuntimeValue::Int(v) => Some(*v),
            _ => None,
        }
    }

    fn as_array(&self) -> Option<Rc<RefCell<Vec<RuntimeValue>>>> {
        match self {
            RuntimeValue::Array(items) => Some(items.clone()),
            _ => None,
        }
    }

    fn as_object(&self) -> Option<Rc<RefCell<HashMap<String, RuntimeValue>>>> {
        match self {
            RuntimeValue::Object(map) => Some(map.clone()),
            _ => None,
        }
    }

    fn from_constant(constant: &ConstantValue) -> Self {
        match constant {
            ConstantValue::Int(v) => RuntimeValue::Int(*v),
            ConstantValue::Float(v) => RuntimeValue::Float(*v),
            ConstantValue::Bool(v) => RuntimeValue::Bool(*v),
            ConstantValue::String(v) => RuntimeValue::String(v.clone()),
            ConstantValue::Null => RuntimeValue::Null,
        }
    }

    fn equals(&self, other: &RuntimeValue) -> RuntimeValue {
        RuntimeValue::Bool(self == other)
    }

    fn not_equals(&self, other: &RuntimeValue) -> RuntimeValue {
        RuntimeValue::Bool(self != other)
    }

    fn compare(&self, other: &RuntimeValue, cmp: fn(f64, f64) -> bool) -> Option<RuntimeValue> {
        Some(RuntimeValue::Bool(cmp(self.as_f64()?, other.as_f64()?)))
    }
}

impl fmt::Display for RuntimeValue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RuntimeValue::Int(v) => write!(f, "{v}"),
            RuntimeValue::Float(v) => write!(f, "{v}"),
            RuntimeValue::Bool(v) => write!(f, "{v}"),
            RuntimeValue::String(v) => write!(f, "{v}"),
            RuntimeValue::Array(values) => {
                let elems: Vec<String> = values.borrow().iter().map(|v| v.to_string()).collect();
                write!(f, "[{}]", elems.join(", "))
            }
            RuntimeValue::Object(map) => {
                let map = map.borrow();
                let mut parts: Vec<String> = map.iter().map(|(k, v)| format!("{k}: {v}")).collect();
                parts.sort();
                write!(f, "{{{}}}", parts.join(", "))
            }
            RuntimeValue::Function(func) => write!(f, "<fn:{}>", func.index()),
            RuntimeValue::Null => write!(f, "null"),
        }
    }
}

pub struct IrInterpreter<'m> {
    module: &'m SolvraIrModule,
}

impl<'m> IrInterpreter<'m> {
    pub fn new(module: &'m SolvraIrModule) -> Self {
        Self { module }
    }

    pub fn run_entry(
        &self,
        name: &str,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue, IrInterpreterError> {
        let function = self
            .module
            .function_by_name(name)
            .ok_or_else(|| IrInterpreterError::UnknownFunction(name.to_string()))?;
        self.run_function(function, args)
    }

    pub fn run_function_by_id(
        &self,
        id: FunctionId,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue, IrInterpreterError> {
        let function = self
            .module
            .function(id)
            .ok_or_else(|| IrInterpreterError::UnknownFunction(format!("id:{}", id.index())))?;
        self.run_function(function, args)
    }

    pub fn run_function(
        &self,
        function: &FunctionIR,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue, IrInterpreterError> {
        let mut values = vec![None; function.values().len()];
        // Seed parameter values
        for (index, param_id) in function.parameters().iter().enumerate() {
            let arg = args.get(index).cloned().unwrap_or(RuntimeValue::Null);
            values[param_id.index()] = Some(arg);
        }
        // Seed constants
        for value in function.values() {
            if let ValueKind::Constant(constant) = &value.kind {
                values[value.id.index()] = Some(RuntimeValue::from_constant(constant));
            }
        }

        let mut current_block = function.entry_block;
        let mut previous_block: Option<BlockId> = None;
        loop {
            let block_id = current_block;
            let block = function.block(block_id).clone();
            for instruction in &block.instructions {
                let result = match &instruction.opcode {
                    IrOpcode::Phi => {
                        self.evaluate_phi(&block, previous_block, &instruction.operands, &values)?
                    }
                    IrOpcode::Add => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        runtime_add(lhs, rhs)?
                    }
                    IrOpcode::Sub => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        RuntimeValue::Float(
                            lhs.as_f64().ok_or(IrInterpreterError::OperandType("sub"))?
                                - rhs.as_f64().ok_or(IrInterpreterError::OperandType("sub"))?,
                        )
                    }
                    IrOpcode::Mul => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        RuntimeValue::Float(
                            lhs.as_f64().ok_or(IrInterpreterError::OperandType("mul"))?
                                * rhs.as_f64().ok_or(IrInterpreterError::OperandType("mul"))?,
                        )
                    }
                    IrOpcode::Div => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        RuntimeValue::Float(
                            lhs.as_f64().ok_or(IrInterpreterError::OperandType("div"))?
                                / rhs.as_f64().ok_or(IrInterpreterError::OperandType("div"))?,
                        )
                    }
                    IrOpcode::And => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        RuntimeValue::Bool(
                            lhs.as_bool()
                                .ok_or(IrInterpreterError::OperandType("and"))?
                                && rhs
                                    .as_bool()
                                    .ok_or(IrInterpreterError::OperandType("and"))?,
                        )
                    }
                    IrOpcode::Or => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        RuntimeValue::Bool(
                            lhs.as_bool().ok_or(IrInterpreterError::OperandType("or"))?
                                || rhs.as_bool().ok_or(IrInterpreterError::OperandType("or"))?,
                        )
                    }
                    IrOpcode::Rem => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        match (&lhs, &rhs) {
                            (RuntimeValue::Int(a), RuntimeValue::Int(b)) => {
                                RuntimeValue::Int(a % b)
                            }
                            _ => RuntimeValue::Float(
                                lhs.as_f64().ok_or(IrInterpreterError::OperandType("rem"))?
                                    % rhs.as_f64().ok_or(IrInterpreterError::OperandType("rem"))?,
                            ),
                        }
                    }
                    IrOpcode::ArrayMake => {
                        let mut items = Vec::new();
                        for operand in &instruction.operands {
                            items.push(self.load(&values, *operand)?);
                        }
                        RuntimeValue::Array(Rc::new(RefCell::new(items)))
                    }
                    IrOpcode::ArrayGet => {
                        if instruction.operands.len() != 2 {
                            return Err(IrInterpreterError::Runtime(
                                "array.get requires two operands".into(),
                            ));
                        }
                        let array = self.load(&values, instruction.operands[0])?;
                        let index = self.load(&values, instruction.operands[1])?;
                        let array_ref = array
                            .as_array()
                            .ok_or(IrInterpreterError::OperandType("array_get"))?;
                        let idx = index
                            .as_int()
                            .ok_or(IrInterpreterError::OperandType("array_get"))?;
                        let data = array_ref.borrow();
                        let len = data.len() as i64;
                        if idx < 0 || idx >= len {
                            return Err(IrInterpreterError::Runtime("index out of bounds".into()));
                        }
                        data[idx as usize].clone()
                    }
                    IrOpcode::ArraySet => {
                        if instruction.operands.len() != 3 {
                            return Err(IrInterpreterError::Runtime(
                                "array.set requires three operands".into(),
                            ));
                        }
                        let array = self.load(&values, instruction.operands[0])?;
                        let index = self.load(&values, instruction.operands[1])?;
                        let value = self.load(&values, instruction.operands[2])?;
                        let array_ref = array
                            .as_array()
                            .ok_or(IrInterpreterError::OperandType("array_set"))?;
                        let idx = index
                            .as_int()
                            .ok_or(IrInterpreterError::OperandType("array_set"))?;
                        let mut data = array_ref.borrow_mut();
                        if idx < 0 || idx as usize >= data.len() {
                            return Err(IrInterpreterError::Runtime("index out of bounds".into()));
                        }
                        data[idx as usize] = value.clone();
                        RuntimeValue::Null
                    }
                    IrOpcode::ObjectNew => {
                        RuntimeValue::Object(Rc::new(RefCell::new(HashMap::new())))
                    }
                    IrOpcode::ObjectGet => {
                        if instruction.operands.len() != 2 {
                            return Err(IrInterpreterError::Runtime(
                                "object.get requires two operands".into(),
                            ));
                        }
                        let object = self.load(&values, instruction.operands[0])?;
                        let key = self.load(&values, instruction.operands[1])?;
                        let key_str = match key {
                            RuntimeValue::String(text) => text,
                            _ => {
                                return Err(IrInterpreterError::OperandType("object_get"));
                            }
                        };
                        if let Some(map) = object.as_object() {
                            let borrowed = map.borrow();
                            borrowed
                                .get(&key_str)
                                .cloned()
                                .unwrap_or(RuntimeValue::Null)
                        } else {
                            return Err(IrInterpreterError::OperandType("object_get"));
                        }
                    }
                    IrOpcode::ObjectSet => {
                        if instruction.operands.len() != 3 {
                            return Err(IrInterpreterError::Runtime(
                                "object.set requires three operands".into(),
                            ));
                        }
                        let object = self.load(&values, instruction.operands[0])?;
                        let key = self.load(&values, instruction.operands[1])?;
                        let value = self.load(&values, instruction.operands[2])?;
                        let key_str = match key {
                            RuntimeValue::String(text) => text,
                            _ => {
                                return Err(IrInterpreterError::OperandType("object_set"));
                            }
                        };
                        let map = object
                            .as_object()
                            .ok_or(IrInterpreterError::OperandType("object_set"))?;
                        map.borrow_mut().insert(key_str, value.clone());
                        RuntimeValue::Object(map)
                    }
                    IrOpcode::ArrayLen => {
                        let array = self.load(&values, instruction.operands[0])?;
                        let array_ref = array
                            .as_array()
                            .ok_or(IrInterpreterError::OperandType("array_len"))?;
                        RuntimeValue::Int(array_ref.borrow().len() as i64)
                    }
                    IrOpcode::Neg => {
                        let value = self.load(&values, instruction.operands[0])?;
                        RuntimeValue::Float(
                            -value
                                .as_f64()
                                .ok_or(IrInterpreterError::OperandType("neg"))?,
                        )
                    }
                    IrOpcode::Not => {
                        let value = self.load(&values, instruction.operands[0])?;
                        RuntimeValue::Bool(
                            !value
                                .as_bool()
                                .ok_or(IrInterpreterError::OperandType("not"))?,
                        )
                    }
                    IrOpcode::CmpEq => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        lhs.equals(&rhs)
                    }
                    IrOpcode::CmpNe => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        lhs.not_equals(&rhs)
                    }
                    IrOpcode::CmpLt => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        lhs.compare(&rhs, |l, r| l < r)
                            .ok_or(IrInterpreterError::OperandType("cmp_lt"))?
                    }
                    IrOpcode::CmpLe => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        lhs.compare(&rhs, |l, r| l <= r)
                            .ok_or(IrInterpreterError::OperandType("cmp_le"))?
                    }
                    IrOpcode::CmpGt => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        lhs.compare(&rhs, |l, r| l > r)
                            .ok_or(IrInterpreterError::OperandType("cmp_gt"))?
                    }
                    IrOpcode::CmpGe => {
                        let lhs = self.load(&values, instruction.operands[0])?;
                        let rhs = self.load(&values, instruction.operands[1])?;
                        lhs.compare(&rhs, |l, r| l >= r)
                            .ok_or(IrInterpreterError::OperandType("cmp_ge"))?
                    }
                    IrOpcode::Guard(guard) => {
                        let value = self.load(&values, guard.value)?;
                        match guard.kind {
                            GuardKind::Truthy => {
                                if !value
                                    .as_bool()
                                    .ok_or(IrInterpreterError::OperandType("guard"))?
                                {
                                    return Err(IrInterpreterError::OperandType("guard"));
                                }
                            }
                            GuardKind::Type(_)
                            | GuardKind::Shape(_)
                            | GuardKind::Range { .. }
                            | GuardKind::Custom(_) => {
                                // Phase 1: skip enforcement besides ensuring the value exists.
                            }
                        }
                        continue;
                    }
                    IrOpcode::Call { target } => {
                        let mut args = Vec::new();
                        for operand in &instruction.operands {
                            args.push(self.load(&values, *operand)?);
                        }
                        match target {
                            CallTarget::Internal(func_id) => {
                                let function = self.module.function(*func_id).ok_or_else(|| {
                                    IrInterpreterError::Runtime(format!(
                                        "function {:?} missing from module",
                                        func_id
                                    ))
                                })?;
                                self.run_function(function, &args)?
                            }
                            CallTarget::External { symbol } => {
                                self.invoke_builtin(symbol.as_str(), &args)?
                            }
                            CallTarget::Intrinsic { name } => self.invoke_builtin(name, &args)?,
                            CallTarget::Dynamic => {
                                if args.is_empty() {
                                    return Err(IrInterpreterError::Runtime(
                                        "dynamic call missing callee".into(),
                                    ));
                                }
                                let callee = args.remove(0);
                                self.call_value(callee, &args)?
                            }
                            CallTarget::Method { name } => {
                                if args.is_empty() {
                                    return Err(IrInterpreterError::Runtime(
                                        "method call missing receiver".into(),
                                    ));
                                }
                                let receiver = args.remove(0);
                                self.call_method(receiver, &name, &args)?
                            }
                        }
                    }
                    IrOpcode::StackMapRef(_) | IrOpcode::Nop | IrOpcode::Constant => continue,
                    _ => {
                        return Err(IrInterpreterError::UnsupportedOpcode(
                            "opcode not supported in IR interpreter",
                        ));
                    }
                };
                if let Some(result_id) = instruction.result {
                    values[result_id.index()] = Some(result);
                }
            }

            let terminator = block
                .terminator
                .as_ref()
                .expect("verifier ensures terminators are present");
            match &terminator.kind {
                TerminatorKind::Return { value } => {
                    if let Some(value) = value {
                        return self.load(&values, *value);
                    }
                    return Ok(RuntimeValue::Null);
                }
                TerminatorKind::Jump { target } => {
                    previous_block = Some(block_id);
                    current_block = *target;
                }
                TerminatorKind::Branch {
                    condition,
                    then_block,
                    else_block,
                } => {
                    let cond = self
                        .load(&values, *condition)?
                        .as_bool()
                        .ok_or(IrInterpreterError::BranchCondition)?;
                    previous_block = Some(block_id);
                    current_block = if cond { *then_block } else { *else_block };
                }
            }
        }
    }

    fn call_value(
        &self,
        callee: RuntimeValue,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue, IrInterpreterError> {
        match callee {
            RuntimeValue::Function(id) => {
                let function = self.module.function(id).ok_or_else(|| {
                    IrInterpreterError::Runtime("unknown function reference".into())
                })?;
                self.run_function(function, args)
            }
            RuntimeValue::String(name) => self.invoke_builtin(&name, args),
            _ => Err(IrInterpreterError::Runtime(format!(
                "{} is not callable",
                callee
            ))),
        }
    }

    fn call_method(
        &self,
        receiver: RuntimeValue,
        method: &str,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue, IrInterpreterError> {
        if let Some(object) = receiver.as_object() {
            if let Some(value) = object.borrow().get(method) {
                let mut call_args = Vec::with_capacity(args.len() + 1);
                call_args.push(receiver.clone());
                call_args.extend_from_slice(args);
                return self.call_value(value.clone(), &call_args);
            }
        }

        if matches!(method, "keys" | "values" | "has_key") {
            let mut builtin_args = Vec::with_capacity(args.len() + 1);
            builtin_args.push(receiver);
            builtin_args.extend_from_slice(args);
            return self.invoke_builtin(method, &builtin_args);
        }

        Err(IrInterpreterError::Runtime(format!(
            "method '{method}' is not callable"
        )))
    }

    fn invoke_builtin(
        &self,
        name: &str,
        args: &[RuntimeValue],
    ) -> Result<RuntimeValue, IrInterpreterError> {
        match name {
            "prt" | "print" => {
                write_values_to_stdout(args, false)
                    .map_err(|err| IrInterpreterError::Runtime(err.to_string()))?;
                Ok(RuntimeValue::Null)
            }
            "println" => {
                write_values_to_stdout(args, true)
                    .map_err(|err| IrInterpreterError::Runtime(err.to_string()))?;
                Ok(RuntimeValue::Null)
            }
            "len" => builtin_len(args),
            "keys" => builtin_keys(args),
            "values" => builtin_values(args),
            "has_key" => builtin_has_key(args),
            _ => Err(IrInterpreterError::Runtime(format!(
                "builtin `{name}` not supported in IR mode"
            ))),
        }
    }

    fn load(
        &self,
        values: &[Option<RuntimeValue>],
        value_id: ValueId,
    ) -> Result<RuntimeValue, IrInterpreterError> {
        values
            .get(value_id.index())
            .and_then(|v| v.clone())
            .ok_or(IrInterpreterError::MissingValue(value_id))
    }

    fn evaluate_phi(
        &self,
        block: &crate::ir::block::BasicBlock,
        previous_block: Option<BlockId>,
        operands: &[ValueId],
        values: &[Option<RuntimeValue>],
    ) -> Result<RuntimeValue, IrInterpreterError> {
        let index = previous_block
            .and_then(|pred| {
                block
                    .predecessors
                    .iter()
                    .position(|candidate| *candidate == pred)
            })
            .unwrap_or(0);
        let operand_id = operands
            .get(index)
            .copied()
            .or_else(|| operands.first().copied())
            .ok_or_else(|| IrInterpreterError::Runtime("phi node missing operands".into()))?;
        self.load(values, operand_id)
    }
}

impl Tier0Module for SolvraIrModule {
    type Value = RuntimeValue;
    type Error = IrInterpreterError;

    fn run_function_by_id(
        &self,
        id: Tier0FunctionId,
        args: &[Self::Value],
    ) -> Result<Self::Value, Self::Error> {
        let interpreter = IrInterpreter::new(self);
        interpreter.run_function_by_id(FunctionId::from(id), args)
    }
}

fn write_values_to_stdout(args: &[RuntimeValue], newline: bool) -> io::Result<()> {
    let mut stdout = io::stdout().lock();
    for value in args {
        write!(stdout, "{}", format_runtime_value(value))?;
    }
    if newline {
        writeln!(stdout)?;
    }
    stdout.flush()
}

fn format_runtime_value(value: &RuntimeValue) -> String {
    match value {
        RuntimeValue::Array(items) => {
            let parts: Vec<String> = items.borrow().iter().map(format_runtime_value).collect();
            format!("[{}]", parts.join(", "))
        }
        RuntimeValue::Object(map) => {
            let mut fields: Vec<String> = map
                .borrow()
                .iter()
                .map(|(k, v)| format!("{k}: {}", format_runtime_value(v)))
                .collect();
            fields.sort();
            format!("{{{}}}", fields.join(", "))
        }
        _ => value.to_string(),
    }
}

fn runtime_add(lhs: RuntimeValue, rhs: RuntimeValue) -> Result<RuntimeValue, IrInterpreterError> {
    if let Some(result) = runtime_string_add(&lhs, &rhs) {
        return Ok(RuntimeValue::String(result));
    }
    match (lhs, rhs) {
        (RuntimeValue::Int(a), RuntimeValue::Int(b)) => Ok(RuntimeValue::Int(a + b)),
        (RuntimeValue::Float(a), RuntimeValue::Float(b)) => Ok(RuntimeValue::Float(a + b)),
        (RuntimeValue::Int(a), RuntimeValue::Float(b)) => Ok(RuntimeValue::Float(a as f64 + b)),
        (RuntimeValue::Float(a), RuntimeValue::Int(b)) => Ok(RuntimeValue::Float(a + b as f64)),
        (RuntimeValue::Null, RuntimeValue::Int(b)) => Ok(RuntimeValue::Int(b)),
        (RuntimeValue::Int(a), RuntimeValue::Null) => Ok(RuntimeValue::Int(a)),
        (RuntimeValue::Null, RuntimeValue::Float(b)) => Ok(RuntimeValue::Float(b)),
        (RuntimeValue::Float(a), RuntimeValue::Null) => Ok(RuntimeValue::Float(a)),
        _ => Err(IrInterpreterError::OperandType("add")),
    }
}

fn runtime_string_add(lhs: &RuntimeValue, rhs: &RuntimeValue) -> Option<String> {
    match (lhs, rhs) {
        (RuntimeValue::String(left), RuntimeValue::String(right)) => {
            let mut result = left.clone();
            result.push_str(right);
            Some(result)
        }
        (RuntimeValue::String(left), other) => {
            let mut result = left.clone();
            result.push_str(&format_runtime_value(other));
            Some(result)
        }
        (other, RuntimeValue::String(right)) => {
            let mut result = format_runtime_value(other);
            result.push_str(right);
            Some(result)
        }
        _ => None,
    }
}

fn builtin_len(args: &[RuntimeValue]) -> Result<RuntimeValue, IrInterpreterError> {
    let value = args
        .get(0)
        .ok_or_else(|| IrInterpreterError::Runtime("len() expects one argument".into()))?;
    match value {
        RuntimeValue::String(text) => Ok(RuntimeValue::Int(text.chars().count() as i64)),
        RuntimeValue::Array(items) => Ok(RuntimeValue::Int(items.borrow().len() as i64)),
        RuntimeValue::Object(map) => Ok(RuntimeValue::Int(map.borrow().len() as i64)),
        _ => Err(IrInterpreterError::Runtime(format!(
            "len() not supported for type {}",
            value
        ))),
    }
}

fn builtin_keys(args: &[RuntimeValue]) -> Result<RuntimeValue, IrInterpreterError> {
    let value = args
        .get(0)
        .ok_or_else(|| IrInterpreterError::Runtime("keys() expects object argument".into()))?;
    let object = value
        .as_object()
        .ok_or_else(|| IrInterpreterError::Runtime("keys() expects object argument".into()))?;
    let keys = object
        .borrow()
        .keys()
        .cloned()
        .map(RuntimeValue::String)
        .collect::<Vec<_>>();
    Ok(RuntimeValue::Array(Rc::new(RefCell::new(keys))))
}

fn builtin_values(args: &[RuntimeValue]) -> Result<RuntimeValue, IrInterpreterError> {
    let value = args
        .get(0)
        .ok_or_else(|| IrInterpreterError::Runtime("values() expects object argument".into()))?;
    let object = value
        .as_object()
        .ok_or_else(|| IrInterpreterError::Runtime("values() expects object argument".into()))?;
    let values = object.borrow().values().cloned().collect::<Vec<_>>();
    Ok(RuntimeValue::Array(Rc::new(RefCell::new(values))))
}

fn builtin_has_key(args: &[RuntimeValue]) -> Result<RuntimeValue, IrInterpreterError> {
    if args.len() != 2 {
        return Err(IrInterpreterError::Runtime(
            "has_key() expects object and key arguments".into(),
        ));
    }
    let object = args[0]
        .as_object()
        .ok_or_else(|| IrInterpreterError::Runtime("has_key() expects object argument".into()))?;
    let key = match &args[1] {
        RuntimeValue::String(text) => text.clone(),
        _ => {
            return Err(IrInterpreterError::Runtime(
                "has_key() expects string key".into(),
            ));
        }
    };
    Ok(RuntimeValue::Bool(object.borrow().contains_key(&key)))
}

//==============================================
// End of file
//==============================================
