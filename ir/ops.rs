//==============================================
// File: solvra_script/ir/ops.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Define SolvraIR opcodes and guard metadata
// Objective: Enumerate arithmetic, control-flow, and runtime instructions plus guard forms
//==============================================

use crate::ir::block::BlockId;
use crate::ir::function::CallTarget;
use crate::ir::types::TypeDescriptor;
use crate::ir::value::ValueId;

/// SSA opcodes emitted by the builder.
#[derive(Debug, Clone, PartialEq)]
pub enum IrOpcode {
    Nop,
    Phi,
    Constant,
    Add,
    Sub,
    Mul,
    Div,
    Rem,
    And,
    Or,
    ArrayMake,
    ArrayGet,
    ArraySet,
    ArrayLen,
    ObjectNew,
    Neg,
    Not,
    CmpEq,
    CmpNe,
    CmpLt,
    CmpLe,
    CmpGt,
    CmpGe,
    Load,
    Store,
    ObjectGet,
    ObjectSet,
    Call { target: CallTarget },
    Guard(Guard),
    StackMapRef(u32),
}

/// Branch terminators supported by SolvraIR.
#[derive(Debug, Clone, PartialEq)]
pub enum TerminatorKind {
    Return {
        value: Option<ValueId>,
    },
    Jump {
        target: BlockId,
    },
    Branch {
        condition: ValueId,
        then_block: BlockId,
        else_block: BlockId,
    },
}

/// Terminator wrapper storing debug info.
#[derive(Debug, Clone, PartialEq)]
pub struct Terminator {
    pub kind: TerminatorKind,
    pub debug_name: Option<String>,
}

impl Terminator {
    pub fn new(kind: TerminatorKind) -> Self {
        Self {
            kind,
            debug_name: None,
        }
    }
}

/// Guard metadata used for speculative execution tracking.
#[derive(Debug, Clone, PartialEq)]
pub struct Guard {
    pub kind: GuardKind,
    pub value: ValueId,
    pub message: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum GuardKind {
    Type(TypeDescriptor),
    Shape(u32),
    Range { min: i64, max: i64 },
    Truthy,
    Custom(&'static str),
}

/// Instruction representation storing opcode and operands.
#[derive(Debug, Clone)]
pub struct Instruction {
    pub opcode: IrOpcode,
    pub operands: Vec<ValueId>,
    pub ty: Option<TypeDescriptor>,
    pub result: Option<ValueId>,
    pub debug_name: Option<String>,
}

impl Instruction {
    pub fn new(
        opcode: IrOpcode,
        operands: Vec<ValueId>,
        ty: Option<TypeDescriptor>,
        result: Option<ValueId>,
    ) -> Self {
        Self {
            opcode,
            operands,
            ty,
            result,
            debug_name: None,
        }
    }
}

//==============================================
// End of file
//==============================================
