//==============================================
// File: solvra_script/ir/verify.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Perform lightweight IR validation
// Objective: Provide structural checks used during development until the full verifier ships
//==============================================

use crate::ir::block::BlockId;
use crate::ir::function::{CallTarget, FunctionIR};
use crate::ir::ops::{IrOpcode, TerminatorKind};
use crate::ir::value::{ValueId, ValueKind};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum IrVerifyError {
    #[error("block {0} is missing a terminator")]
    MissingTerminator(BlockId),
    #[error("block {0} targets unknown block")]
    UnknownTarget(BlockId),
    #[error("value {0} referenced before creation")]
    UnknownValue(ValueId),
    #[error("block {0} must be sealed before verification")]
    UnsealedBlock(BlockId),
    #[error("block {0} is unreachable from entry block")]
    UnreachableBlock(BlockId),
    #[error("block {from} lists invalid successor {to}")]
    InvalidSuccessor { from: BlockId, to: BlockId },
    #[error("block {0} successor list does not match its terminator")]
    SuccessorMismatch(BlockId),
    #[error("value {0} violates SSA dominance rules")]
    DominanceViolation(ValueId),
    #[error("opcode {opcode} expects {expected} operands, got {actual}")]
    InvalidOperandCount {
        opcode: &'static str,
        expected: usize,
        actual: usize,
    },
}

pub fn verify_function(function: &FunctionIR) -> Result<(), IrVerifyError> {
    let block_count = function.blocks.len();
    let value_count = function.values().len();
    if block_count == 0 {
        return Err(IrVerifyError::MissingTerminator(BlockId(0)));
    }

    for block in &function.blocks {
        if !block.sealed {
            return Err(IrVerifyError::UnsealedBlock(block.id));
        }
        if block.terminator.is_none() {
            return Err(IrVerifyError::MissingTerminator(block.id));
        }
    }

    // Reachability
    let mut reachable = vec![false; block_count];
    let mut stack = vec![function.entry_block];
    let mut traversal = Vec::new();
    while let Some(block_id) = stack.pop() {
        if reachable[block_id.index()] {
            continue;
        }
        reachable[block_id.index()] = true;
        traversal.push(block_id);
        let block = function.block(block_id);
        if let Some(terminator) = &block.terminator {
            match &terminator.kind {
                TerminatorKind::Jump { target } => stack.push(*target),
                TerminatorKind::Branch {
                    then_block,
                    else_block,
                    ..
                } => {
                    stack.push(*then_block);
                    stack.push(*else_block);
                }
                TerminatorKind::Return { .. } => {}
            }
        }
    }

    for block in &function.blocks {
        if !reachable[block.id.index()] {
            return Err(IrVerifyError::UnreachableBlock(block.id));
        }
    }

    // Dominance tracking: parameters/constants available at start.
    let mut available = vec![false; value_count];
    for value in function.values() {
        match value.kind {
            ValueKind::Parameter(_) | ValueKind::Constant(_) => {
                available[value.id.index()] = true;
            }
            _ => {}
        }
    }

    for block_id in traversal {
        let block = function.block(block_id);
        for instruction in &block.instructions {
            let is_phi = matches!(instruction.opcode, IrOpcode::Phi);
            for operand in &instruction.operands {
                if operand.index() >= value_count {
                    return Err(IrVerifyError::UnknownValue(*operand));
                }
                if !is_phi && !available[operand.index()] {
                    return Err(IrVerifyError::DominanceViolation(*operand));
                }
            }
            if let Some(result) = instruction.result {
                available[result.index()] = true;
            }

            let operand_len = instruction.operands.len();
            let ensure_count = |opcode, expected| -> Result<(), IrVerifyError> {
                if operand_len != expected {
                    Err(IrVerifyError::InvalidOperandCount {
                        opcode,
                        expected,
                        actual: operand_len,
                    })
                } else {
                    Ok(())
                }
            };
            match &instruction.opcode {
                IrOpcode::Add => ensure_count("add", 2)?,
                IrOpcode::Sub => ensure_count("sub", 2)?,
                IrOpcode::Mul => ensure_count("mul", 2)?,
                IrOpcode::Div => ensure_count("div", 2)?,
                IrOpcode::Rem => ensure_count("rem", 2)?,
                IrOpcode::And => ensure_count("and", 2)?,
                IrOpcode::Or => ensure_count("or", 2)?,
                IrOpcode::CmpEq => ensure_count("cmp_eq", 2)?,
                IrOpcode::CmpNe => ensure_count("cmp_ne", 2)?,
                IrOpcode::CmpLt => ensure_count("cmp_lt", 2)?,
                IrOpcode::CmpLe => ensure_count("cmp_le", 2)?,
                IrOpcode::CmpGt => ensure_count("cmp_gt", 2)?,
                IrOpcode::CmpGe => ensure_count("cmp_ge", 2)?,
                IrOpcode::Neg => ensure_count("neg", 1)?,
                IrOpcode::Not => ensure_count("not", 1)?,
                IrOpcode::ArrayLen => ensure_count("array_len", 1)?,
                IrOpcode::ArrayGet => ensure_count("array_get", 2)?,
                IrOpcode::ArraySet => ensure_count("array_set", 3)?,
                IrOpcode::ObjectNew => ensure_count("object_new", 0)?,
                IrOpcode::ObjectGet => ensure_count("object_get", 2)?,
                IrOpcode::ObjectSet => ensure_count("object_set", 3)?,
                IrOpcode::Call { target } => match target {
                    CallTarget::Dynamic => {
                        if operand_len < 1 {
                            return Err(IrVerifyError::InvalidOperandCount {
                                opcode: "call_dynamic",
                                expected: 1,
                                actual: operand_len,
                            });
                        }
                    }
                    _ => {}
                },
                _ => {}
            }
        }

        match &block.terminator.as_ref().unwrap().kind {
            TerminatorKind::Return { value } => {
                if let Some(value) = value {
                    if value.index() >= value_count {
                        return Err(IrVerifyError::UnknownValue(*value));
                    }
                    if !available[value.index()] {
                        return Err(IrVerifyError::DominanceViolation(*value));
                    }
                }
            }
            TerminatorKind::Jump { target } => {
                if target.index() >= block_count {
                    return Err(IrVerifyError::UnknownTarget(*target));
                }
            }
            TerminatorKind::Branch {
                condition,
                then_block,
                else_block,
            } => {
                if condition.index() >= value_count {
                    return Err(IrVerifyError::UnknownValue(*condition));
                }
                if !available[condition.index()] {
                    return Err(IrVerifyError::DominanceViolation(*condition));
                }
                if then_block.index() >= block_count {
                    return Err(IrVerifyError::UnknownTarget(*then_block));
                }
                if else_block.index() >= block_count {
                    return Err(IrVerifyError::UnknownTarget(*else_block));
                }
            }
        }

        for successor in &block.successors {
            if successor.index() >= block_count {
                return Err(IrVerifyError::InvalidSuccessor {
                    from: block.id,
                    to: *successor,
                });
            }
        }

        let mut recorded = block.successors.clone();
        recorded.sort_by_key(|id| id.index());
        let mut expected = match &block.terminator.as_ref().unwrap().kind {
            TerminatorKind::Jump { target } => vec![*target],
            TerminatorKind::Branch {
                then_block,
                else_block,
                ..
            } => vec![*then_block, *else_block],
            TerminatorKind::Return { .. } => Vec::new(),
        };
        recorded.dedup();
        expected.sort_by_key(|id| id.index());
        if recorded != expected {
            return Err(IrVerifyError::SuccessorMismatch(block.id));
        }
    }
    Ok(())
}

//==============================================
// End of file
//==============================================
