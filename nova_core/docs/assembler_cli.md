# NovaCore Assembler Guide

The NovaCore crate exposes the bytecode assembler as a library so it can be
embedded in tooling such as NovaShell, NovaIDE, or automated build scripts.  The
steps below show how to assemble `.novac` programs using the crate.

## Build and Environment Setup

```bash
# Build host artifacts and run the test suite
./build/run-all.sh
```

The helper wraps `cargo build --all-targets` for both the native host and the
`aarch64-unknown-linux-gnu` cross target before running `cargo test`.

## Assembling Programs

NovaCore currently assembles from the high-level AST provided by the
NovaScript front-end.  The example below converts an AST into bytecode and
writes the resulting `.novac` file:

```rust
use nova_core::bytecode::assemble;
use nova_core::bytecode::ast::{Ast, Expr};

fn assemble_sample() -> anyhow::Result<()> {
    let ast = Ast::from_expr(Expr::string("Hello from NovaCore!"));
    let bytecode = assemble(&ast)?;
    std::fs::write("hello.novac", bytecode.into_bytes())?;
    Ok(())
}
```

You can run the snippet with `cargo run --example embed_runtime` and tailor the
AST to match your program.  Projects that already produce `.novac` text files
(such as the fixtures in `samples/`) can parse the directives and emit the
binary layout defined in [`novac_format.md`](./novac_format.md) before writing
out the compiled artifact.

## Inspecting Output

The generated bytecode is self-contained.  Use `hexdump -C hello.novac` or a
custom inspector to verify the magic header (`NVAC`), version, and section
sizes.  The driver framework native functions (`driver_register`,
`driver_write_u32`, etc.) are available to any module that references them by
name.

## Automating Assembly

Continuous integration environments can call the helper scripts in
`nova_core/build/` to cross-compile NovaCore and rebuild `.novac` artifacts in a
single step.  For example:

```bash
# Assemble and then run the runtime smoke tests
./build/cargo-desktop.sh
cargo run --example embed_runtime
```

This approach keeps the assembler embedded in the Rust toolchain without
requiring additional binaries.
