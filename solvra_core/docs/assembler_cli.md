# SolvraCore Assembler Guide

The SolvraCore crate exposes the bytecode assembler as a library so it can be
embedded in tooling such as SolvraShell, SolvraIDE, or automated build scripts.  The
steps below show how to assemble `.svc` programs using the crate.

## Build and Environment Setup

```bash
# Build host artifacts and run the test suite
./build/run-all.sh
```

The helper wraps `cargo build --all-targets` for both the native host and the
`aarch64-unknown-linux-gnu` cross target before running `cargo test`.

## Assembling Programs

SolvraCore currently assembles from the high-level AST provided by the
SolvraScript front-end.  The example below converts an AST into bytecode and
writes the resulting `.svc` file:

```rust
use solvra_core::bytecode::assemble;
use solvra_core::bytecode::ast::{Ast, Expr};

fn assemble_sample() -> anyhow::Result<()> {
    let ast = Ast::from_expr(Expr::string("Hello from SolvraCore!"));
    let bytecode = assemble(&ast)?;
    std::fs::write("hello.svc", bytecode.into_bytes())?;
    Ok(())
}
```

You can run the snippet with `cargo run --example embed_runtime` and tailor the
AST to match your program.  Projects that already produce `.svc` text files
(such as the fixtures in `samples/`) can parse the directives and emit the
binary layout defined in [`svc_format.md`](./svc_format.md) before writing
out the compiled artifact.

## Inspecting Output

The generated bytecode is self-contained.  Use `hexdump -C hello.svc` or a
custom inspector to verify the magic header (`SVC1`), version, and section
sizes.  The driver framework native functions (`driver_register`,
`driver_write_u32`, etc.) are available to any module that references them by
name.

## Automating Assembly

Continuous integration environments can call the helper scripts in
`solvra_core/build/` to cross-compile SolvraCore and rebuild `.svc` artifacts in a
single step.  For example:

```bash
# Assemble and then run the runtime smoke tests
./build/cargo-desktop.sh
cargo run --example embed_runtime
```

This approach keeps the assembler embedded in the Rust toolchain without
requiring additional binaries.
