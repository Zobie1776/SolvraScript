// Advanced SolvraScript feature demonstration covering complex behaviors.
// Exercises lambdas, closures, mutability, collections, and control flow.

const ZERO = 0;
let mut counter = 0;

fn factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

fn safe_divide(a, b) {
    if (b == 0) {
        return [0, 1]; // error code 1 signals divide-by-zero
    }
    return [a / b, 0];
}

fn increment(value) {
    return value + 1;
}

fn apply_twice(func, value) {
    return func(func(value));
}

fn map_array(items, func) {
    let mut result = [];
    let mut index = 0;
    while (index < len(items)) {
        result = push(result, func(items[index]));
        index = index + 1;
    }
    return result;
}

fn find_in_pairs(pairs, key) {
    let mut idx = 0;
    while (idx < len(pairs)) {
        let entry = pairs[idx];
        if (entry[0] == key) {
            return [entry[1], 0];
        }
        idx = idx + 1;
    }
    return [null, -1];
}

// Prepare mutable data and demonstrate dynamic array operations.
let mut numbers = [1, 2, 3];
numbers = push(numbers, 4);
numbers = push(numbers, 5);

let mut total = 0;
let mut cursor = 0;
while (cursor < len(numbers)) {
    total = total + numbers[cursor];
    counter = counter + 1;
    cursor = cursor + 1;
}

prt("numbers = " + numbers + ", total = " + total + ", loop_count = " + counter + "\n");

let rec_result = factorial(5);
let doubled = map_array(numbers, increment);
let applied = apply_twice(increment, 10);
prt(" incremented copy = " + doubled + "\n");

let offset = 7;
let adder = lambda |x| -> x + offset;
let inline_lambda = apply_twice(lambda |x| -> x * 2, 3);

let info_pairs = [
    [" status ", " ok "],
    [" rec ", rec_result],
    [" count ", len(numbers)],
];

let lookup_status = find_in_pairs(info_pairs, " status ");
let lookup_missing = find_in_pairs(info_pairs, " missing ");

let division_ok = safe_divide(42, 6);
let division_fail = safe_divide(42, ZERO);

let mut summary_lines = [];
summary_lines = push(summary_lines, " factorial(5) = " + rec_result);
summary_lines = push(summary_lines, " apply_twice = " + applied);
summary_lines = push(summary_lines, " status = " + lookup_status[0]);
summary_lines = push(summary_lines, " missing? code = " + lookup_missing[1]);
summary_lines = push(summary_lines, " adder(10) = " + adder(10));
summary_lines = push(summary_lines, " inline_lambda = " + inline_lambda);

let mut i = 0;
while (i < len(summary_lines)) {
    prt(" summary [" + i + "] -> " + summary_lines[i]);
    endl();
    i = i + 1;
}

if (division_fail[1] != 0) {
    prt(" safe_divide failed with code " + division_fail[1]);
    endl();
} else if (division_ok[1] != 0) {
    prt(" unexpected error from division_ok");
    endl();
} else {
    prt(" division results: " + division_ok[0]);
    endl();
}

const GREETING = "Hello! ";
{
    let GREETING = "Hi, ";
    let message = GREETING + "from inner scope";
    prt(message);
    endl();
}
prt(GREETING + "from outer scope\n");
prt("closure uses offset -> " + adder(5));
endl();
