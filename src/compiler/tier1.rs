#![allow(dead_code)]

//==================================================
// File: solvra_script/tier1.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Bridge SolvraScript SSA IR to Tier-1 MIR
// Objective: Provide lowering utilities, MIR dumps, and regalloc diagnostics
//==================================================

use crate::ir::block::BasicBlock;
use crate::ir::function::{CallTarget, FunctionIR};
use crate::ir::ir::SolvraIrModule;
use crate::ir::ops::{GuardKind, Instruction, IrOpcode, TerminatorKind};
use crate::ir::types::{PrimitiveType, TypeDescriptor};
use crate::ir::value::{ConstantValue, ValueData, ValueId, ValueKind};
use solvra_core::jit::code_cache::Tier1CodeCache;
use solvra_core::jit::tier1_codegen::Tier1FusedIcArtifact;
use solvra_core::jit::tier1_lowering::{
    MirLoweringContext, SsaBlock, SsaCallTarget, SsaCmpOp, SsaFunctionView, SsaInstruction,
    SsaOpcode, SsaTerminator, SsaValueId,
};
use solvra_core::jit::tier1_mir::{MirFunctionId, MirModule, MirValueKind};
use solvra_core::jit::tier1_osr::{Tier1OsrRegistry, ValueTransferPlan};
use solvra_core::jit::tier1_peep::peephole_optimize_module;
use solvra_core::jit::tier1_regalloc::{self, ModuleAllocation, export_regalloc_to_transfer_plan};
use solvra_core::jit::tier1_typeinfer::type_infer_module;
use solvra_core::jit::verify_mir::{MirVerifyError, verify_module};
use std::collections::HashMap;

#[derive(Debug)]
pub struct LoweredTier1Module {
    pub module: MirModule,
    pub osr_registry: Tier1OsrRegistry,
}

impl LoweredTier1Module {
    pub fn transfer_plan(&self, function: MirFunctionId) -> Option<&ValueTransferPlan> {
        self.osr_registry.transfer_plan(function)
    }
}

pub fn lower_ir_to_mir(module: &SolvraIrModule) -> LoweredTier1Module {
    let mut mir_module = MirModule::new();
    let mut osr_registry = Tier1OsrRegistry::new();
    {
        let mut ctx = MirLoweringContext::new(&mut mir_module);
        for function in module.functions() {
            let view = IrFunctionView::new(module, function);
            ctx.lower_function(&view, &mut osr_registry);
        }
    }
    peephole_optimize_module(&mut mir_module);
    type_infer_module(&mut mir_module);
    let allocation = tier1_regalloc::allocate(&mir_module);
    for function in mir_module.functions() {
        if let Some(result) = allocation.get(function.id) {
            export_regalloc_to_transfer_plan(function, result, &mut osr_registry);
        }
    }
    LoweredTier1Module {
        module: mir_module,
        osr_registry,
    }
}

pub fn verify_lowered_module(module: &MirModule) -> Result<(), MirVerifyError> {
    verify_module(module)
}

pub fn dump_mir(module: &MirModule) {
    for function in module.functions() {
        println!("fn {}(", function.name);
        for block in &function.blocks {
            println!("  bb{}:", block.id.0);
            for inst in &block.instructions {
                println!("    {:?}", inst.opcode);
            }
            println!(
                "    // preds: {:?} succs: {:?}",
                block
                    .predecessors
                    .iter()
                    .map(|pred| pred.0)
                    .collect::<Vec<_>>(),
                block
                    .successors
                    .iter()
                    .map(|succ| succ.0)
                    .collect::<Vec<_>>()
            );
        }
        println!(")");
    }
}

pub fn print_fused_ic_summary(module: &MirModule, artifacts: &[Tier1FusedIcArtifact]) {
    if artifacts.is_empty() {
        println!("[tier1][fused] (no fused IC artifacts)");
        return;
    }
    println!("[tier1][fused] Tier-1 fused IC artifacts:");
    for artifact in artifacts {
        let name = module
            .function(artifact.function_id)
            .map(|func| func.name.as_str())
            .unwrap_or("<unknown>");
        println!(
            " - fn={} site={} version={} kind={:?} hits={}",
            name, artifact.site_id, artifact.version, artifact.kind, artifact.stats.hits
        );
    }
}

pub fn dump_fused_ic_summary(cache: &Tier1CodeCache) {
    let artifacts = cache.fused_ic_artifacts_snapshot();
    if artifacts.is_empty() {
        println!("[tier1][fused] (no fused IC artifacts)");
        return;
    }
    println!("[tier1][fused] Tier-1 fused IC artifacts:");
    for artifact in artifacts {
        let name = cache
            .function_name(artifact.function_id)
            .unwrap_or("<unknown>");
        println!(
            " - fn={} site={} version={} hits={}",
            name, artifact.site_id, artifact.version, artifact.stats.hits
        );
    }
}

pub fn dump_osr_landing_pads(mir: &MirModule, cache: &Tier1CodeCache) {
    println!("[tier1][osr] landing pads:");
    for function in mir.functions() {
        let pads = cache.landing_pads(function.id);
        println!("fn {}:", function.name);
        if pads.is_empty() {
            println!("  (no landing pads)");
            continue;
        }
        for (idx, pad) in pads.iter().enumerate() {
            println!(
                "  pad {}: bb {}, osr {}, schema=locals:{} temps:{} stack:{}",
                idx,
                pad.bb_id.0,
                pad.osr_point.0,
                pad.snapshot_schema.locals,
                pad.snapshot_schema.temps,
                pad.snapshot_schema.stack
            );
        }
    }
}

pub fn dump_regalloc(module: &MirModule) -> ModuleAllocation {
    let allocation = tier1_regalloc::allocate(module);
    for function in module.functions() {
        println!("// RegAlloc {}", function.name);
        if let Some(result) = allocation.get(function.id) {
            for (slot, reg) in &result.reg_map {
                println!("  value {} -> r{}", slot, reg.0);
            }
            for (slot, spill) in &result.spill_map {
                println!("  value {} -> spill {}", slot, spill);
            }
            for summary in &result.summaries {
                let location = match &summary.location {
                    solvra_core::jit::tier1_regalloc::IntervalLocation::Register(reg) => {
                        format!("r{}", reg.0)
                    }
                    solvra_core::jit::tier1_regalloc::IntervalLocation::Spill(slot) => {
                        format!("spill{}", slot)
                    }
                    solvra_core::jit::tier1_regalloc::IntervalLocation::None => "-".into(),
                };
                println!(
                    "  interval v{} [{}..{}] weight={:.2} loop_hot={} branch={} -> {}",
                    summary.value,
                    summary.start,
                    summary.end,
                    summary.weight,
                    summary.loop_hot,
                    summary.branch_critical,
                    location
                );
            }
        } else {
            println!("  (no allocation)");
        }
    }
    allocation
}

struct IrFunctionView<'a> {
    module: &'a SolvraIrModule,
    function: &'a FunctionIR,
    values: HashMap<SsaValueId, &'a ValueData>,
}

impl<'a> IrFunctionView<'a> {
    fn new(module: &'a SolvraIrModule, function: &'a FunctionIR) -> Self {
        let mut values = HashMap::new();
        for value in function.values() {
            values.insert(value.id.0, value);
        }
        Self {
            module,
            function,
            values,
        }
    }

    fn lower_block(&self, block: &BasicBlock) -> SsaBlock {
        let instructions = block
            .instructions
            .iter()
            .filter_map(|instruction| self.lower_instruction(block, instruction))
            .collect();
        let terminator = self.lower_terminator(block);
        SsaBlock {
            id: block.id.0,
            instructions,
            terminator,
        }
    }

    fn lower_instruction(
        &self,
        block: &BasicBlock,
        instruction: &Instruction,
    ) -> Option<SsaInstruction> {
        let opcode = self.lower_opcode(block, instruction)?;
        let ty = instruction
            .ty
            .as_ref()
            .map(map_type)
            .unwrap_or(MirValueKind::Ref);
        Some(SsaInstruction {
            result: instruction.result.map(|value| value.0),
            opcode,
            ty,
        })
    }

    fn lower_opcode(&self, block: &BasicBlock, instruction: &Instruction) -> Option<SsaOpcode> {
        match &instruction.opcode {
            IrOpcode::Nop | IrOpcode::StackMapRef(_) => None,
            IrOpcode::Phi => Some(SsaOpcode::Phi {
                sources: self
                    .gather_phi_sources(block, &instruction.operands)
                    .unwrap_or_default(),
            }),
            IrOpcode::Constant => {
                let value = instruction.result.and_then(|id| self.constant_value(id));
                value.map(|constant| match constant {
                    ConstantValue::Int(value) => SsaOpcode::Integer { value: *value },
                    ConstantValue::Float(value) => SsaOpcode::Float { value: *value },
                    ConstantValue::Bool(value) => SsaOpcode::Boolean { value: *value },
                    ConstantValue::String(text) => SsaOpcode::String {
                        value: text.clone(),
                    },
                    ConstantValue::Null => SsaOpcode::Null,
                })
            }
            IrOpcode::Add => {
                Some(self.binary_op(instruction, |lhs, rhs| SsaOpcode::Add { lhs, rhs }))
            }
            IrOpcode::Sub => {
                Some(self.binary_op(instruction, |lhs, rhs| SsaOpcode::Sub { lhs, rhs }))
            }
            IrOpcode::Mul => {
                Some(self.binary_op(instruction, |lhs, rhs| SsaOpcode::Mul { lhs, rhs }))
            }
            IrOpcode::Div => {
                Some(self.binary_op(instruction, |lhs, rhs| SsaOpcode::Div { lhs, rhs }))
            }
            IrOpcode::Rem => {
                Some(self.binary_op(instruction, |lhs, rhs| SsaOpcode::Rem { lhs, rhs }))
            }
            IrOpcode::And => {
                Some(self.binary_op(instruction, |lhs, rhs| SsaOpcode::And { lhs, rhs }))
            }
            IrOpcode::Or => {
                Some(self.binary_op(instruction, |lhs, rhs| SsaOpcode::Or { lhs, rhs }))
            }
            IrOpcode::ArrayMake => Some(SsaOpcode::ArrayLiteral {
                elements: instruction.operands.iter().map(|value| value.0).collect(),
            }),
            IrOpcode::ArrayGet => Some(SsaOpcode::ArrayGet {
                base: instruction.operands.get(0).map(|id| id.0).unwrap_or(0),
                index: instruction.operands.get(1).map(|id| id.0).unwrap_or(0),
            }),
            IrOpcode::ArraySet => Some(SsaOpcode::ArraySet {
                base: instruction.operands.get(0).map(|id| id.0).unwrap_or(0),
                index: instruction.operands.get(1).map(|id| id.0).unwrap_or(0),
                value: instruction.operands.get(2).map(|id| id.0).unwrap_or(0),
            }),
            IrOpcode::Slice => None,
            IrOpcode::ArrayLen => Some(SsaOpcode::ArrayLen {
                base: instruction.operands.get(0).map(|id| id.0).unwrap_or(0),
            }),
            IrOpcode::ObjectNew => Some(SsaOpcode::ObjectLiteral {
                properties: Vec::new(),
            }),
            IrOpcode::Neg => instruction
                .operands
                .get(0)
                .map(|value| SsaOpcode::Neg { value: value.0 }),
            IrOpcode::Not => instruction
                .operands
                .get(0)
                .map(|value| SsaOpcode::Not { value: value.0 }),
            IrOpcode::CmpEq => Some(self.compare_op(instruction, SsaCmpOp::Eq)),
            IrOpcode::CmpNe => Some(self.compare_op(instruction, SsaCmpOp::Ne)),
            IrOpcode::CmpLt => Some(self.compare_op(instruction, SsaCmpOp::Lt)),
            IrOpcode::CmpLe => Some(self.compare_op(instruction, SsaCmpOp::Le)),
            IrOpcode::CmpGt => Some(self.compare_op(instruction, SsaCmpOp::Gt)),
            IrOpcode::CmpGe => Some(self.compare_op(instruction, SsaCmpOp::Ge)),
            IrOpcode::Load => instruction
                .operands
                .get(0)
                .map(|value| SsaOpcode::Load { source: value.0 }),
            IrOpcode::Store => Some(SsaOpcode::Store {
                target: instruction.operands.get(0).map(|id| id.0).unwrap_or(0),
                value: instruction.operands.get(1).map(|id| id.0).unwrap_or(0),
            }),
            IrOpcode::ObjectGet => {
                let key = instruction
                    .operands
                    .get(1)
                    .and_then(|value| self.string_constant(*value))
                    .unwrap_or_else(|| "<unknown>".into());
                Some(SsaOpcode::ObjectGet {
                    base: instruction.operands.get(0).map(|id| id.0).unwrap_or(0),
                    key,
                })
            }
            IrOpcode::ObjectSet => {
                let key = instruction
                    .operands
                    .get(1)
                    .and_then(|value| self.string_constant(*value))
                    .unwrap_or_else(|| "<unknown>".into());
                Some(SsaOpcode::ObjectSet {
                    base: instruction.operands.get(0).map(|id| id.0).unwrap_or(0),
                    key,
                    value: instruction.operands.get(2).map(|id| id.0).unwrap_or(0),
                })
            }
            IrOpcode::Call { target } => {
                let args = instruction.operands.iter().map(|value| value.0).collect();
                let (call_target, poly) = self.map_call_target(target);
                Some(SsaOpcode::Call {
                    target: call_target,
                    args,
                    poly,
                })
            }
            IrOpcode::Guard(guard) => match &guard.kind {
                GuardKind::Type(descriptor) => Some(SsaOpcode::GuardType {
                    value: guard.value.0,
                    expected: map_type(descriptor),
                }),
                GuardKind::Shape(shape) => Some(SsaOpcode::GuardShape {
                    value: guard.value.0,
                    shape: format!("shape#{shape}"),
                }),
                other => Some(SsaOpcode::GuardShape {
                    value: guard.value.0,
                    shape: format!("{other:?}"),
                }),
            },
        }
    }

    fn lower_terminator(&self, block: &BasicBlock) -> SsaTerminator {
        match &block.terminator {
            Some(terminator) => match &terminator.kind {
                TerminatorKind::Return { value } => SsaTerminator::Return {
                    value: value.map(|value| value.0),
                },
                TerminatorKind::Jump { target } => SsaTerminator::Jump { target: target.0 },
                TerminatorKind::Branch {
                    condition,
                    then_block,
                    else_block,
                } => SsaTerminator::Branch {
                    condition: condition.0,
                    true_block: then_block.0,
                    false_block: else_block.0,
                },
            },
            None => SsaTerminator::Return { value: None },
        }
    }

    fn gather_phi_sources(
        &self,
        block: &BasicBlock,
        operands: &[ValueId],
    ) -> Option<Vec<(SsaValueId, SsaValueId)>> {
        if block.predecessors.is_empty() && operands.is_empty() {
            return None;
        }
        let mut sources = Vec::new();
        for (index, predecessor) in block.predecessors.iter().enumerate() {
            if let Some(value) = operands.get(index) {
                sources.push((predecessor.0, value.0));
            }
        }
        if sources.is_empty() {
            for value in operands {
                sources.push((block.id.0, value.0));
            }
        }
        Some(sources)
    }

    fn binary_op<F>(&self, instruction: &Instruction, op: F) -> SsaOpcode
    where
        F: FnOnce(SsaValueId, SsaValueId) -> SsaOpcode,
    {
        let lhs = instruction.operands.get(0).map(|id| id.0).unwrap_or(0);
        let rhs = instruction.operands.get(1).map(|id| id.0).unwrap_or(0);
        op(lhs, rhs)
    }

    fn compare_op(&self, instruction: &Instruction, op: SsaCmpOp) -> SsaOpcode {
        let lhs = instruction.operands.get(0).map(|id| id.0).unwrap_or(0);
        let rhs = instruction.operands.get(1).map(|id| id.0).unwrap_or(0);
        SsaOpcode::Cmp { op, lhs, rhs }
    }

    fn constant_value(&self, id: ValueId) -> Option<&ConstantValue> {
        self.values.get(&id.0).and_then(|value| match &value.kind {
            ValueKind::Constant(constant) => Some(constant),
            _ => None,
        })
    }

    fn string_constant(&self, id: ValueId) -> Option<String> {
        self.constant_value(id).and_then(|constant| {
            if let ConstantValue::String(text) = constant {
                Some(text.clone())
            } else {
                None
            }
        })
    }

    fn map_call_target(&self, target: &CallTarget) -> (SsaCallTarget, bool) {
        match target {
            CallTarget::Internal(function_id) => {
                let name = self
                    .module
                    .function(*function_id)
                    .map(|func| func.name.clone())
                    .unwrap_or_else(|| format!("fn#{}", function_id.0));
                (SsaCallTarget::Static(name), false)
            }
            CallTarget::External { symbol } => (SsaCallTarget::Static(symbol.clone()), false),
            CallTarget::Intrinsic { name } => (SsaCallTarget::Static((*name).to_string()), false),
            CallTarget::Dynamic => (SsaCallTarget::Virtual("dynamic".into()), true),
            CallTarget::Method { name } => (SsaCallTarget::Virtual(name.clone()), true),
        }
    }
}

impl<'a> SsaFunctionView for IrFunctionView<'a> {
    fn name(&self) -> &str {
        &self.function.name
    }

    fn parameter_kinds(&self) -> Vec<MirValueKind> {
        self.function
            .signature
            .params
            .iter()
            .map(map_type)
            .collect()
    }

    fn blocks(&self) -> Vec<SsaBlock> {
        self.function
            .blocks
            .iter()
            .map(|block| self.lower_block(block))
            .collect()
    }
}

fn map_type(descriptor: &TypeDescriptor) -> MirValueKind {
    match descriptor.primitive {
        PrimitiveType::Bool => MirValueKind::Bool,
        PrimitiveType::Int32 => MirValueKind::I32,
        PrimitiveType::Int64 => MirValueKind::I64,
        PrimitiveType::Float64 => MirValueKind::F64,
        PrimitiveType::String => MirValueKind::Ref,
        PrimitiveType::Object | PrimitiveType::Array | PrimitiveType::Any => MirValueKind::Ref,
        PrimitiveType::Function => MirValueKind::Ptr,
        PrimitiveType::Void => MirValueKind::Ptr,
    }
}

//==================================================
// End of file
//==================================================
