#![allow(dead_code)]

//==============================================
// File: solvra_script/ir/builder.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Provide SSA builder utilities
// Objective: Expose APIs that create blocks, emit instructions, and attach terminators
//==============================================

use crate::ir::block::BlockId;
use crate::ir::function::FunctionIR;
use crate::ir::ops::{IrOpcode, Terminator, TerminatorKind};
use crate::ir::types::{Ownership, TypeDescriptor};
use crate::ir::value::{ConstantValue, ValueId};
/// Errors surfaced when manipulating blocks.
#[derive(Debug, thiserror::Error)]
pub enum BlockBuilderError {
    #[error("block {0} is not part of this function")]
    UnknownBlock(BlockId),
    #[error("block {0} already has a terminator")]
    BlockTerminated(BlockId),
}

/// Builder that appends SSA instructions to a function.
pub struct FunctionBuilder<'a> {
    function: &'a mut FunctionIR,
    current_block: BlockId,
}

impl<'a> FunctionBuilder<'a> {
    pub fn new(function: &'a mut FunctionIR) -> Self {
        let entry = function.entry_block;
        Self {
            function,
            current_block: entry,
        }
    }

    pub fn function(&self) -> &FunctionIR {
        self.function
    }

    pub fn function_mut(&mut self) -> &mut FunctionIR {
        self.function
    }

    pub fn parameters(&self) -> &[ValueId] {
        self.function.parameters()
    }

    pub fn append_block(&mut self, label: impl Into<String>) -> BlockId {
        self.function.create_block(Some(label.into()))
    }

    pub fn position_at_end(&mut self, block: BlockId) -> Result<(), BlockBuilderError> {
        self.ensure_block(block)?;
        self.current_block = block;
        Ok(())
    }

    pub fn current_block(&self) -> BlockId {
        self.current_block
    }

    pub fn block_has_terminator(&self, block: BlockId) -> bool {
        self.function.block(block).terminator.is_some()
    }

    pub fn seal_block(&mut self, block: BlockId) -> Result<(), BlockBuilderError> {
        self.ensure_block(block)?;
        self.function.block_mut(block).sealed = true;
        Ok(())
    }

    pub fn finalize(&mut self) {
        for block in &mut self.function.blocks {
            block.sealed = true;
        }
    }

    pub fn make_constant(&mut self, value: ConstantValue, ty: TypeDescriptor) -> ValueId {
        self.function.alloc_constant(value, ty)
    }

    pub fn emit_value(
        &mut self,
        opcode: IrOpcode,
        operands: Vec<ValueId>,
        ty: TypeDescriptor,
        ownership: Ownership,
        debug_name: Option<String>,
    ) -> Result<ValueId, BlockBuilderError> {
        let block = self.current_block;
        self.ensure_block(block)?;
        self.function
            .append_instruction(block, opcode, operands, Some(ty), ownership, debug_name)
            .ok_or(BlockBuilderError::UnknownBlock(block))
    }

    pub fn emit_void(
        &mut self,
        opcode: IrOpcode,
        operands: Vec<ValueId>,
        debug_name: Option<String>,
    ) -> Result<(), BlockBuilderError> {
        let block = self.current_block;
        self.ensure_block(block)?;
        self.function.append_instruction(
            block,
            opcode,
            operands,
            None,
            Ownership::Shared,
            debug_name,
        );
        Ok(())
    }

    pub fn emit_return(&mut self, value: Option<ValueId>) -> Result<(), BlockBuilderError> {
        self.finish_with(TerminatorKind::Return { value })
    }

    pub fn emit_jump(&mut self, target: BlockId) -> Result<(), BlockBuilderError> {
        self.finish_with(TerminatorKind::Jump { target })
    }

    pub fn emit_branch(
        &mut self,
        condition: ValueId,
        then_block: BlockId,
        else_block: BlockId,
    ) -> Result<(), BlockBuilderError> {
        self.finish_with(TerminatorKind::Branch {
            condition,
            then_block,
            else_block,
        })
    }

    fn finish_with(&mut self, kind: TerminatorKind) -> Result<(), BlockBuilderError> {
        let block = self.current_block;
        self.ensure_block(block)?;
        {
            let bb = self.function.block_mut(block);
            if bb.terminator.is_some() {
                return Err(BlockBuilderError::BlockTerminated(block));
            }
            bb.terminator = Some(Terminator::new(kind.clone()));
        }
        match &kind {
            TerminatorKind::Jump { target } => {
                self.register_edge(block, *target)?;
            }
            TerminatorKind::Branch {
                then_block,
                else_block,
                ..
            } => {
                self.register_edge(block, *then_block)?;
                self.register_edge(block, *else_block)?;
            }
            TerminatorKind::Return { .. } => {}
        }
        Ok(())
    }

    fn ensure_block(&self, block: BlockId) -> Result<(), BlockBuilderError> {
        if block.index() >= self.function.blocks.len() {
            return Err(BlockBuilderError::UnknownBlock(block));
        }
        Ok(())
    }

    fn register_edge(&mut self, from: BlockId, to: BlockId) -> Result<(), BlockBuilderError> {
        self.ensure_block(to)?;
        {
            let block = self.function.block_mut(from);
            if !block.successors.contains(&to) {
                block.successors.push(to);
            }
        }
        {
            let target = self.function.block_mut(to);
            if !target.predecessors.contains(&from) {
                target.predecessors.push(from);
            }
        }
        Ok(())
    }
}

//==============================================
// End of file
//==============================================
