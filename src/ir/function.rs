#![allow(dead_code)]

//==============================================
// File: solvra_script/ir/function.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Store SolvraIR function data
// Objective: Track blocks, values, stack maps, and deoptimization metadata
//==============================================

use crate::ir::block::{BasicBlock, BlockId};
use crate::ir::display::IrFormatter;
use crate::ir::ops::{Instruction, IrOpcode, Terminator};
use crate::ir::types::{BorrowKind, Ownership, PrimitiveType, TypeDescriptor};
use crate::ir::value::{ConstantValue, InstructionId, ValueData, ValueId, ValueKind};
use solvra_core::jit::tier0_codegen::{Tier0Function, Tier0FunctionId};

/// Identifier assigned to functions inside a module.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FunctionId(pub(crate) u32);

impl FunctionId {
    pub fn index(self) -> usize {
        self.0 as usize
    }
}

impl From<u32> for FunctionId {
    fn from(value: u32) -> Self {
        FunctionId(value)
    }
}

impl From<FunctionId> for u32 {
    fn from(id: FunctionId) -> Self {
        id.0
    }
}

/// Function calling contract.
#[derive(Debug, Clone, PartialEq)]
pub struct FunctionSignature {
    pub params: Vec<TypeDescriptor>,
    pub result: TypeDescriptor,
}

impl FunctionSignature {
    pub fn new(params: Vec<TypeDescriptor>, result: TypeDescriptor) -> Self {
        Self { params, result }
    }
}

/// Description of a call destination.
#[derive(Debug, Clone, PartialEq)]
pub enum CallTarget {
    Internal(FunctionId),
    External { symbol: String },
    Intrinsic { name: &'static str },
    Dynamic,
    Method { name: String },
}

/// Stack slot metadata consumed by GC + deoptimizer.
#[derive(Debug, Clone, PartialEq)]
pub struct StackSlot {
    pub index: usize,
    pub ty: TypeDescriptor,
    pub live: bool,
}

/// Stack map stored per safepoint.
#[derive(Debug, Clone, PartialEq)]
pub struct StackMap {
    pub id: u32,
    pub block: BlockId,
    pub slots: Vec<StackSlot>,
}

/// Deoptimization metadata associated with guards.
#[derive(Debug, Clone, PartialEq)]
pub struct DeoptRecord {
    pub stack_map: u32,
    pub resume_block: BlockId,
    pub reason: String,
}

/// Complete SSA function.
#[derive(Debug, Clone)]
pub struct FunctionIR {
    pub id: FunctionId,
    pub name: String,
    pub signature: FunctionSignature,
    pub blocks: Vec<BasicBlock>,
    pub entry_block: BlockId,
    pub parameters: Vec<ValueId>,
    pub stack_maps: Vec<StackMap>,
    pub deopts: Vec<DeoptRecord>,
    values: Vec<ValueData>,
    next_block: u32,
    next_value: u32,
}

impl FunctionIR {
    pub fn new(id: FunctionId, name: impl Into<String>, signature: FunctionSignature) -> Self {
        let mut function = Self {
            id,
            name: name.into(),
            signature: signature.clone(),
            blocks: Vec::new(),
            entry_block: BlockId(0),
            parameters: Vec::new(),
            stack_maps: Vec::new(),
            deopts: Vec::new(),
            values: Vec::new(),
            next_block: 0,
            next_value: 0,
        };

        for (index, ty) in signature.params.into_iter().enumerate() {
            let value_id = function.alloc_value(
                ty,
                Ownership::Borrowed(BorrowKind::Immutable),
                ValueKind::Parameter(index),
                Some(format!("arg{}", index)),
            );
            function.parameters.push(value_id);
        }

        let entry = function.create_block(Some("entry".into()));
        function.entry_block = entry;
        function
    }

    pub fn parameters(&self) -> &[ValueId] {
        &self.parameters
    }

    pub fn values(&self) -> &[ValueData] {
        &self.values
    }

    pub fn block(&self, block: BlockId) -> &BasicBlock {
        &self.blocks[block.index()]
    }

    pub fn block_mut(&mut self, block: BlockId) -> &mut BasicBlock {
        &mut self.blocks[block.index()]
    }

    pub fn create_block(&mut self, name: Option<String>) -> BlockId {
        let block_id = BlockId(self.next_block);
        self.next_block += 1;
        self.blocks.push(BasicBlock::new(block_id, name));
        block_id
    }

    pub fn append_instruction(
        &mut self,
        block: BlockId,
        opcode: IrOpcode,
        operands: Vec<ValueId>,
        ty: Option<TypeDescriptor>,
        ownership: Ownership,
        debug_name: Option<String>,
    ) -> Option<ValueId> {
        let result = ty.clone().map(|ty| {
            self.alloc_value(
                ty,
                ownership,
                ValueKind::Instruction(InstructionId(self.next_value)),
                debug_name.clone(),
            )
        });
        let mut instruction = Instruction::new(opcode, operands, ty, result);
        instruction.debug_name = debug_name;
        self.block_mut(block).instructions.push(instruction);
        result
    }

    pub fn set_terminator(&mut self, block: BlockId, terminator: Terminator) {
        let block = self.block_mut(block);
        block.terminator = Some(terminator);
    }

    pub fn alloc_stack_map(&mut self, block: BlockId, slots: Vec<StackSlot>) -> u32 {
        let id = self.stack_maps.len() as u32;
        self.stack_maps.push(StackMap { id, block, slots });
        id
    }

    pub fn add_deopt(&mut self, stack_map: u32, resume_block: BlockId, reason: impl Into<String>) {
        self.deopts.push(DeoptRecord {
            stack_map,
            resume_block,
            reason: reason.into(),
        });
    }

    pub fn alloc_constant(&mut self, value: ConstantValue, ty: TypeDescriptor) -> ValueId {
        self.alloc_value(ty, Ownership::Owned, ValueKind::Constant(value), None)
    }

    fn alloc_value(
        &mut self,
        ty: TypeDescriptor,
        ownership: Ownership,
        kind: ValueKind,
        debug_name: Option<String>,
    ) -> ValueId {
        let id = ValueId(self.next_value);
        self.next_value += 1;
        self.values
            .push(ValueData::new(id, ty, ownership, kind, debug_name));
        id
    }

    pub fn void_type() -> TypeDescriptor {
        TypeDescriptor::primitive(PrimitiveType::Void)
    }
}

impl Tier0Function for FunctionIR {
    fn tier0_listing(&self) -> String {
        IrFormatter::new(self).to_string()
    }

    fn tier0_function_id(&self) -> Tier0FunctionId {
        self.id.index() as Tier0FunctionId
    }

    fn tier0_function_name(&self) -> &str {
        &self.name
    }
}

//==============================================
// End of file
//==============================================
