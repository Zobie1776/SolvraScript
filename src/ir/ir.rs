//==============================================
// File: solvra_script/ir/ir.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Manage SolvraIR modules
// Objective: Provide storage and lookup utilities for function IR objects
//==============================================

use crate::ir::function::{FunctionIR, FunctionId, FunctionSignature};

/// Top-level SolvraIR module.
#[derive(Debug, Default)]
pub struct SolvraIrModule {
    functions: Vec<FunctionIR>,
}

impl SolvraIrModule {
    pub fn new() -> Self {
        Self {
            functions: Vec::new(),
        }
    }

    pub fn add_function(
        &mut self,
        name: impl Into<String>,
        signature: FunctionSignature,
    ) -> FunctionId {
        let id = FunctionId(self.functions.len() as u32);
        let function = FunctionIR::new(id, name, signature);
        self.functions.push(function);
        id
    }

    pub fn function(&self, id: FunctionId) -> Option<&FunctionIR> {
        self.functions.get(id.index())
    }

    pub fn function_mut(&mut self, id: FunctionId) -> Option<&mut FunctionIR> {
        self.functions.get_mut(id.index())
    }

    pub fn functions(&self) -> &[FunctionIR] {
        &self.functions
    }

    #[allow(dead_code)] // Kept for future passes that need mutable traversal.
    pub fn functions_mut(&mut self) -> &mut [FunctionIR] {
        &mut self.functions
    }

    pub fn function_by_name(&self, name: &str) -> Option<&FunctionIR> {
        self.functions.iter().find(|func| func.name == name)
    }
}

//==============================================
// End of file
//==============================================
