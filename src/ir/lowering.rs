//==============================================
// File: solvra_script/ir/lowering.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Lower SolvraScript AST into SolvraIR
// Objective: Provide Phase 1 SSA construction with basic statement and expression support
//==============================================

use crate::ast::{AssignTarget, BinaryOp, Expr, FunctionDecl, Literal, Program, Stmt, StringPart};
use crate::ir::block::BlockId;
use crate::ir::builder::{BlockBuilderError, FunctionBuilder};
use crate::ir::function::{CallTarget, FunctionIR, FunctionId, FunctionSignature};
use crate::ir::ir::SolvraIrModule;
use crate::ir::ops::IrOpcode;
use crate::ir::types::{ObjectField, ObjectSchema, Ownership, PrimitiveType, TypeDescriptor};
use crate::ir::value::{ConstantValue, ValueId};
use crate::resolver::SymbolResolution;
use crate::symbol::Symbol;
use std::collections::{HashMap, HashSet};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum LoweringError {
    #[error("unsupported statement form: {0}")]
    UnsupportedStatement(&'static str),
    #[error("unsupported expression form: {0}")]
    UnsupportedExpression(&'static str),
    #[error("variable `{0}` is missing an initializer")]
    MissingInitializer(String),
    #[error("symbol `{0}` not found in scope")]
    UnknownIdentifier(String),
    #[error("phi node not found for loop variable")]
    MissingPhi,
    #[error(transparent)]
    Builder(#[from] BlockBuilderError),
}

/// Entry point used by the CLI to translate AST programs into SolvraIR.
pub fn lower_program(
    program: &Program,
    resolutions: &SymbolResolution,
) -> Result<SolvraIrModule, LoweringError> {
    let mut module = SolvraIrModule::new();
    let functions = program.find_functions();
    let mut function_ids = HashMap::new();
    for decl in &functions {
        let signature = signature_from_decl(decl);
        let func_id = module.add_function(decl.name.to_string(), signature);
        function_ids.insert(decl.name.to_string(), func_id);
    }

    for decl in functions {
        if let Some(&func_id) = function_ids.get(decl.name.as_str()) {
            if let Some(function) = module.function_mut(func_id) {
                LoweringContext::new(function, decl, &function_ids, resolutions)?
                    .lower_function(decl)?;
            }
        }
    }
    Ok(module)
}

fn signature_from_decl(decl: &FunctionDecl) -> FunctionSignature {
    let params = decl
        .params
        .iter()
        .map(|_| TypeDescriptor::primitive(PrimitiveType::Any))
        .collect();
    FunctionSignature::new(params, TypeDescriptor::primitive(PrimitiveType::Any))
}

struct Scope {
    values: HashMap<String, ValueId>,
}

impl Scope {
    fn new() -> Self {
        Self {
            values: HashMap::new(),
        }
    }
}

struct LoweringContext<'a> {
    builder: FunctionBuilder<'a>,
    scopes: Vec<Scope>,
    terminated: bool,
    temp_counter: usize,
    functions: &'a HashMap<String, FunctionId>,
    _resolutions: &'a SymbolResolution,
}

impl<'a> LoweringContext<'a> {
    fn new(
        function: &'a mut FunctionIR,
        decl: &FunctionDecl,
        functions: &'a HashMap<String, FunctionId>,
        resolutions: &'a SymbolResolution,
    ) -> Result<Self, LoweringError> {
        let mut ctx = Self {
            builder: FunctionBuilder::new(function),
            scopes: vec![Scope::new()],
            terminated: false,
            temp_counter: 0,
            functions,
            _resolutions: resolutions,
        };
        let params: Vec<ValueId> = ctx.builder.parameters().to_vec();
        for (param, param_decl) in params.into_iter().zip(decl.params.iter()) {
            ctx.define(param_decl.name.to_string(), param);
        }
        Ok(ctx)
    }

    fn lower_function(mut self, decl: &FunctionDecl) -> Result<(), LoweringError> {
        self.lower_statements(&decl.body)?;
        if !self.terminated {
            self.builder.emit_return(None)?;
        }
        self.builder.finalize();
        Ok(())
    }

    fn lower_statements(&mut self, statements: &[Stmt]) -> Result<(), LoweringError> {
        for stmt in statements {
            if self.terminated {
                break;
            }
            self.lower_statement(stmt)?;
        }
        Ok(())
    }

    fn lower_statement(&mut self, stmt: &Stmt) -> Result<(), LoweringError> {
        match stmt {
            Stmt::Expression { expr, .. } => {
                let _ = self.lower_expression(expr)?;
            }
            Stmt::VariableDecl { decl } => {
                let init = decl
                    .initializer
                    .as_ref()
                    .ok_or_else(|| LoweringError::MissingInitializer(decl.name.to_string()))?;
                let value = self.lower_expression(init)?;
                self.define(decl.name.to_string(), value);
            }
            Stmt::Return { value, .. } => {
                if let Some(expr) = value {
                    let lowered = self.lower_expression(expr)?;
                    self.builder.emit_return(Some(lowered))?;
                } else {
                    self.builder.emit_return(None)?;
                }
                self.terminated = true;
            }
            Stmt::Block { statements, .. } => {
                self.push_scope();
                self.lower_statements(statements)?;
                self.pop_scope();
            }
            Stmt::If {
                condition,
                then_branch,
                else_branch,
                ..
            } => {
                self.lower_if(condition, then_branch, else_branch.as_deref())?;
            }
            Stmt::While {
                condition, body, ..
            } => {
                self.lower_while(condition, body)?;
            }
            Stmt::For {
                variable,
                iterable,
                body,
                ..
            } => {
                self.lower_for(variable, iterable, body)?;
            }
            Stmt::Loop { body, .. } => {
                self.lower_loop(body)?;
            }
            _ => {
                return Err(LoweringError::UnsupportedStatement(
                    "statement not supported in Phase 1 lowering",
                ));
            }
        }
        Ok(())
    }

    fn lower_expression(&mut self, expr: &Expr) -> Result<ValueId, LoweringError> {
        match expr {
            Expr::Literal { value, .. } => self.lower_literal(value),
            Expr::List { elements, .. } => self.lower_array_literal(elements),
            Expr::Identifier { name, .. } => self.lookup(name.as_str()),
            Expr::StringTemplate { parts, .. } | Expr::StringInterpolation { parts, .. } => {
                self.lower_string_template(parts)
            }
            Expr::Binary {
                left,
                operator,
                right,
                ..
            } => self.lower_binary_expr(operator, left, right),
            Expr::Unary {
                operator, operand, ..
            } => {
                let value = self.lower_expression(operand)?;
                let opcode = match operator {
                    crate::ast::UnaryOp::Minus => IrOpcode::Neg,
                    crate::ast::UnaryOp::Not => IrOpcode::Not,
                    _ => {
                        return Err(LoweringError::UnsupportedExpression(
                            "unary operator not supported",
                        ));
                    }
                };
                Ok(self.builder.emit_value(
                    opcode,
                    vec![value],
                    TypeDescriptor::primitive(PrimitiveType::Any),
                    Ownership::Owned,
                    None,
                )?)
            }
            Expr::Assign { target, value, .. } => match target {
                AssignTarget::Variable(symbol) => {
                    let lowered = self.lower_expression(value)?;
                    self.assign(symbol.as_str(), lowered)?;
                    Ok(lowered)
                }
                AssignTarget::Index { array, index } => {
                    let array_value = self.lower_expression(array)?;
                    let index_value = self.lower_expression(index)?;
                    let value_value = self.lower_expression(value)?;
                    let _ = self.builder.emit_value(
                        IrOpcode::ArraySet,
                        vec![array_value, index_value, value_value],
                        TypeDescriptor::primitive(PrimitiveType::Any),
                        Ownership::Owned,
                        None,
                    )?;
                    Ok(value_value)
                }
                AssignTarget::Member { object, property } => {
                    let object_value = self.lower_expression(object)?;
                    let key = self.string_constant(property.to_string());
                    let value_value = self.lower_expression(value)?;
                    let _ = self.builder.emit_value(
                        IrOpcode::ObjectSet,
                        vec![object_value, key, value_value],
                        TypeDescriptor::primitive(PrimitiveType::Object),
                        Ownership::Owned,
                        None,
                    )?;
                    Ok(value_value)
                }
            },
            Expr::Call { callee, args, .. } => self.lower_call(callee, args),
            Expr::MethodCall {
                receiver,
                method,
                args,
                ..
            } => self.lower_method_call(receiver, method, args),
            Expr::Member {
                object, property, ..
            } => {
                let object_value = self.lower_expression(object)?;
                let key = self.string_constant(property.to_string());
                Ok(self.builder.emit_value(
                    IrOpcode::ObjectGet,
                    vec![object_value, key],
                    TypeDescriptor::primitive(PrimitiveType::Any),
                    Ownership::Owned,
                    None,
                )?)
            }
            Expr::Index { object, index, .. } => {
                let array = self.lower_expression(object)?;
                let idx = self.lower_expression(index)?;
                Ok(self.builder.emit_value(
                    IrOpcode::ArrayGet,
                    vec![array, idx],
                    TypeDescriptor::primitive(PrimitiveType::Any),
                    Ownership::Owned,
                    None,
                )?)
            }
            Expr::Slice {
                object,
                start,
                end,
                step,
                ..
            } => {
                let array = self.lower_expression(object)?;
                let start_val = if let Some(expr) = start {
                    self.lower_expression(expr)?
                } else {
                    self.null_constant()
                };
                let end_val = if let Some(expr) = end {
                    self.lower_expression(expr)?
                } else {
                    self.null_constant()
                };
                let step_val = if let Some(expr) = step {
                    self.lower_expression(expr)?
                } else {
                    self.null_constant()
                };
                Ok(self.builder.emit_value(
                    IrOpcode::Slice,
                    vec![array, start_val, end_val, step_val],
                    TypeDescriptor::primitive(PrimitiveType::Any),
                    Ownership::Owned,
                    None,
                )?)
            }
            _ => Err(LoweringError::UnsupportedExpression(
                "expression not supported in Phase 1 lowering",
            )),
        }
    }

    fn lower_literal(&mut self, literal: &Literal) -> Result<ValueId, LoweringError> {
        let (constant, ty) = match literal {
            Literal::Integer(value) => (
                ConstantValue::Int(*value),
                TypeDescriptor::primitive(PrimitiveType::Int64),
            ),
            Literal::Float(value) => (
                ConstantValue::Float(*value),
                TypeDescriptor::primitive(PrimitiveType::Float64),
            ),
            Literal::Boolean(value) => (
                ConstantValue::Bool(*value),
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            Literal::String(symbol) => (
                ConstantValue::String(symbol.to_string()),
                TypeDescriptor::primitive(PrimitiveType::String),
            ),
            Literal::Null => (
                ConstantValue::Null,
                TypeDescriptor::primitive(PrimitiveType::Any),
            ),
            Literal::Array(elements) => return self.lower_array_literal(elements),
            Literal::Object(fields) => return self.lower_object_literal(fields),
        };
        Ok(self.builder.make_constant(constant, ty))
    }

    fn push_scope(&mut self) {
        self.scopes.push(Scope::new());
    }

    fn pop_scope(&mut self) {
        self.scopes.pop();
    }

    fn define(&mut self, name: String, value: ValueId) {
        if let Some(scope) = self.scopes.last_mut() {
            scope.values.insert(name, value);
        }
    }

    fn assign(&mut self, name: &str, value: ValueId) -> Result<(), LoweringError> {
        for scope in self.scopes.iter_mut().rev() {
            if scope.values.contains_key(name) {
                scope.values.insert(name.to_string(), value);
                return Ok(());
            }
        }
        Err(LoweringError::UnknownIdentifier(name.to_string()))
    }

    fn lookup(&self, name: &str) -> Result<ValueId, LoweringError> {
        for scope in self.scopes.iter().rev() {
            if let Some(value) = scope.values.get(name) {
                return Ok(*value);
            }
        }
        Err(LoweringError::UnknownIdentifier(name.to_string()))
    }

    fn lower_binary_expr(
        &mut self,
        operator: &BinaryOp,
        left: &Expr,
        right: &Expr,
    ) -> Result<ValueId, LoweringError> {
        let lhs = self.lower_expression(left)?;
        let rhs = self.lower_expression(right)?;
        let (opcode, ty) = match operator {
            BinaryOp::Add => (IrOpcode::Add, TypeDescriptor::primitive(PrimitiveType::Any)),
            BinaryOp::Subtract => (IrOpcode::Sub, TypeDescriptor::primitive(PrimitiveType::Any)),
            BinaryOp::Multiply => (IrOpcode::Mul, TypeDescriptor::primitive(PrimitiveType::Any)),
            BinaryOp::Divide => (IrOpcode::Div, TypeDescriptor::primitive(PrimitiveType::Any)),
            BinaryOp::Modulo => (IrOpcode::Rem, TypeDescriptor::primitive(PrimitiveType::Any)),
            BinaryOp::And => (
                IrOpcode::And,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::Or => (IrOpcode::Or, TypeDescriptor::primitive(PrimitiveType::Bool)),
            BinaryOp::Equal => (
                IrOpcode::CmpEq,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::NotEqual => (
                IrOpcode::CmpNe,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::Less => (
                IrOpcode::CmpLt,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::LessEqual => (
                IrOpcode::CmpLe,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::Greater => (
                IrOpcode::CmpGt,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::GreaterEqual => (
                IrOpcode::CmpGe,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::Is => (
                IrOpcode::CmpEq,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            BinaryOp::IsNot => (
                IrOpcode::CmpNe,
                TypeDescriptor::primitive(PrimitiveType::Bool),
            ),
            _ => {
                return Err(LoweringError::UnsupportedExpression(
                    "binary operator not supported",
                ));
            }
        };
        Ok(self
            .builder
            .emit_value(opcode, vec![lhs, rhs], ty, Ownership::Owned, None)?)
    }

    fn int_constant(&mut self, value: i64) -> ValueId {
        self.builder.make_constant(
            ConstantValue::Int(value),
            TypeDescriptor::primitive(PrimitiveType::Int64),
        )
    }

    fn fresh_name(&mut self, prefix: &str) -> String {
        let name = format!("{}_{}", prefix, self.temp_counter);
        self.temp_counter += 1;
        name
    }

    fn append_phi_operand(
        &mut self,
        block: BlockId,
        phi_value: ValueId,
        operand: ValueId,
    ) -> Result<(), LoweringError> {
        let function = self.builder.function_mut();
        let block_ref = function.block_mut(block);
        if let Some(instruction) = block_ref
            .instructions
            .iter_mut()
            .find(|inst| inst.result == Some(phi_value) && matches!(inst.opcode, IrOpcode::Phi))
        {
            instruction.operands.push(operand);
            Ok(())
        } else {
            Err(LoweringError::MissingPhi)
        }
    }

    fn lower_array_literal(&mut self, elements: &[Expr]) -> Result<ValueId, LoweringError> {
        let mut values = Vec::with_capacity(elements.len());
        for element in elements {
            values.push(self.lower_expression(element)?);
        }
        Ok(self.builder.emit_value(
            IrOpcode::ArrayMake,
            values,
            TypeDescriptor::array(TypeDescriptor::primitive(PrimitiveType::Any)),
            Ownership::Owned,
            None,
        )?)
    }

    fn lower_object_literal(
        &mut self,
        fields: &[(Symbol, Expr)],
    ) -> Result<ValueId, LoweringError> {
        let schema_fields = fields
            .iter()
            .map(|(name, _)| {
                ObjectField::new(
                    name.to_string(),
                    TypeDescriptor::primitive(PrimitiveType::Any),
                )
            })
            .collect::<Vec<_>>();
        let schema = ObjectSchema::new(self.temp_counter as u32).with_fields(schema_fields);
        self.temp_counter += 1;
        let mut object = self.builder.emit_value(
            IrOpcode::ObjectNew,
            Vec::new(),
            TypeDescriptor::object(schema),
            Ownership::Owned,
            None,
        )?;
        for (name, expr) in fields {
            let key = self.string_constant(name.to_string());
            let value = self.lower_expression(expr)?;
            object = self.builder.emit_value(
                IrOpcode::ObjectSet,
                vec![object, key, value],
                TypeDescriptor::primitive(PrimitiveType::Object),
                Ownership::Owned,
                None,
            )?;
        }
        Ok(object)
    }

    fn null_constant(&mut self) -> ValueId {
        self.builder.make_constant(
            ConstantValue::Null,
            TypeDescriptor::primitive(PrimitiveType::Any),
        )
    }

    fn lower_string_template(&mut self, parts: &[StringPart]) -> Result<ValueId, LoweringError> {
        if let Some(text) = flatten_literal_template(parts) {
            Ok(self.builder.make_constant(
                ConstantValue::String(text),
                TypeDescriptor::primitive(PrimitiveType::String),
            ))
        } else {
            Err(LoweringError::UnsupportedExpression(
                "string templates with interpolation are not supported in IR mode",
            ))
        }
    }

    fn lower_call(&mut self, callee: &Expr, args: &[Expr]) -> Result<ValueId, LoweringError> {
        if let Some(name) = self.identifier_name(callee) {
            if let Ok(value) = self.lookup(name) {
                let mut operands = vec![value];
                operands.extend(self.lower_call_args(args)?);
                return self.emit_call(CallTarget::Dynamic, operands);
            }
            if let Some(&function) = self.functions.get(name) {
                let operands = self.lower_call_args(args)?;
                return self.emit_call(CallTarget::Internal(function), operands);
            }
            let operands = self.lower_call_args(args)?;
            return self.emit_call(
                CallTarget::External {
                    symbol: name.to_string(),
                },
                operands,
            );
        }

        let callee_value = self.lower_expression(callee)?;
        let mut operands = vec![callee_value];
        operands.extend(self.lower_call_args(args)?);
        self.emit_call(CallTarget::Dynamic, operands)
    }

    fn lower_method_call(
        &mut self,
        receiver: &Expr,
        method: &Symbol,
        args: &[Expr],
    ) -> Result<ValueId, LoweringError> {
        let recv = self.lower_expression(receiver)?;
        let mut operands = vec![recv];
        operands.extend(self.lower_call_args(args)?);
        self.emit_call(
            CallTarget::Method {
                name: method.to_string(),
            },
            operands,
        )
    }

    fn lower_call_args(&mut self, args: &[Expr]) -> Result<Vec<ValueId>, LoweringError> {
        let mut values = Vec::with_capacity(args.len());
        for arg in args {
            values.push(self.lower_expression(arg)?);
        }
        Ok(values)
    }

    fn emit_call(
        &mut self,
        target: CallTarget,
        operands: Vec<ValueId>,
    ) -> Result<ValueId, LoweringError> {
        Ok(self.builder.emit_value(
            IrOpcode::Call { target },
            operands,
            TypeDescriptor::primitive(PrimitiveType::Any),
            Ownership::Owned,
            None,
        )?)
    }

    fn string_constant(&mut self, value: impl Into<String>) -> ValueId {
        self.builder.make_constant(
            ConstantValue::String(value.into()),
            TypeDescriptor::primitive(PrimitiveType::String),
        )
    }

    fn identifier_name<'b>(&self, expr: &'b Expr) -> Option<&'b str> {
        if let Expr::Identifier { name, .. } = expr {
            Some(name.as_str())
        } else {
            None
        }
    }

    fn lower_for(
        &mut self,
        variable: &Symbol,
        iterable: &Expr,
        body: &Stmt,
    ) -> Result<(), LoweringError> {
        if let Expr::Range {
            start: Some(start),
            end: Some(end),
            ..
        } = iterable
        {
            self.lower_numeric_for(variable, start, end, body)
        } else {
            self.lower_array_for(variable, iterable, body)
        }
    }

    fn lower_numeric_for(
        &mut self,
        variable: &Symbol,
        start: &Expr,
        end: &Expr,
        body: &Stmt,
    ) -> Result<(), LoweringError> {
        self.push_scope();
        let start_value = self.lower_expression(start)?;
        let end_value = self.lower_expression(end)?;
        let end_name = self.fresh_name("for_end");
        self.define(end_name.clone(), end_value);
        let cond_block = self.builder.append_block("for.range.cond");
        let body_block = self.builder.append_block("for.range.body");
        let exit_block = self.builder.append_block("for.range.exit");

        self.builder.emit_jump(cond_block)?;
        self.builder.position_at_end(cond_block)?;
        let loop_ty = TypeDescriptor::primitive(PrimitiveType::Int64);
        let current = self.builder.emit_value(
            IrOpcode::Phi,
            vec![start_value],
            loop_ty.clone(),
            Ownership::Owned,
            None,
        )?;
        self.define(variable.to_string(), current);
        let end_val = self.lookup(&end_name)?;
        let cond_value = self.builder.emit_value(
            IrOpcode::CmpLt,
            vec![current, end_val],
            TypeDescriptor::primitive(PrimitiveType::Bool),
            Ownership::Owned,
            None,
        )?;
        self.builder
            .emit_branch(cond_value, body_block, exit_block)?;

        self.builder.position_at_end(body_block)?;
        self.lower_statement(body)?;
        if !self.builder.block_has_terminator(body_block) {
            let increment = self.int_constant(1);
            let next = self.builder.emit_value(
                IrOpcode::Add,
                vec![current, increment],
                loop_ty,
                Ownership::Owned,
                None,
            )?;
            self.append_phi_operand(cond_block, current, next)?;
            self.builder.emit_jump(cond_block)?;
        }

        self.builder.position_at_end(exit_block)?;
        self.pop_scope();
        Ok(())
    }

    fn lower_array_for(
        &mut self,
        variable: &Symbol,
        iterable: &Expr,
        body: &Stmt,
    ) -> Result<(), LoweringError> {
        self.push_scope();
        let array_value = self.lower_expression(iterable)?;
        let array_name = self.fresh_name("for_array");
        self.define(array_name.clone(), array_value);
        let len_value = self.builder.emit_value(
            IrOpcode::ArrayLen,
            vec![self.lookup(&array_name)?],
            TypeDescriptor::primitive(PrimitiveType::Int64),
            Ownership::Owned,
            None,
        )?;
        let len_name = self.fresh_name("for_len");
        self.define(len_name.clone(), len_value);

        let cond_block = self.builder.append_block("for.array.cond");
        let body_block = self.builder.append_block("for.array.body");
        let exit_block = self.builder.append_block("for.array.exit");

        self.builder.emit_jump(cond_block)?;
        self.builder.position_at_end(cond_block)?;
        let zero_idx = self.int_constant(0);
        let idx_phi = self.builder.emit_value(
            IrOpcode::Phi,
            vec![zero_idx],
            TypeDescriptor::primitive(PrimitiveType::Int64),
            Ownership::Owned,
            None,
        )?;
        let len_value = self.lookup(&len_name)?;
        let cond_value = self.builder.emit_value(
            IrOpcode::CmpLt,
            vec![idx_phi, len_value],
            TypeDescriptor::primitive(PrimitiveType::Bool),
            Ownership::Owned,
            None,
        )?;
        self.builder
            .emit_branch(cond_value, body_block, exit_block)?;

        self.builder.position_at_end(body_block)?;
        let array_val = self.lookup(&array_name)?;
        let element = self.builder.emit_value(
            IrOpcode::ArrayGet,
            vec![array_val, idx_phi],
            TypeDescriptor::primitive(PrimitiveType::Any),
            Ownership::Owned,
            None,
        )?;
        self.define(variable.to_string(), element);
        self.lower_statement(body)?;
        if !self.builder.block_has_terminator(body_block) {
            let increment = self.int_constant(1);
            let next = self.builder.emit_value(
                IrOpcode::Add,
                vec![idx_phi, increment],
                TypeDescriptor::primitive(PrimitiveType::Int64),
                Ownership::Owned,
                None,
            )?;
            self.append_phi_operand(cond_block, idx_phi, next)?;
            self.builder.emit_jump(cond_block)?;
        }

        self.builder.position_at_end(exit_block)?;
        self.pop_scope();
        Ok(())
    }

    fn lower_if(
        &mut self,
        condition: &Expr,
        then_branch: &Stmt,
        else_branch: Option<&Stmt>,
    ) -> Result<(), LoweringError> {
        let cond_value = self.lower_expression(condition)?;
        let then_block = self.builder.append_block("if.then");
        let else_block = else_branch.map(|_| self.builder.append_block("if.else"));
        let merge_block = self.builder.append_block("if.merge");
        let else_target = else_block.unwrap_or(merge_block);
        self.builder
            .emit_branch(cond_value, then_block, else_target)?;
        self.lower_branch_block(then_block, then_branch, merge_block)?;
        if let Some(stmt) = else_branch {
            if let Some(block) = else_block {
                self.lower_branch_block(block, stmt, merge_block)?;
            }
        }
        self.builder.position_at_end(merge_block)?;
        Ok(())
    }

    fn lower_branch_block(
        &mut self,
        start_block: BlockId,
        stmt: &Stmt,
        continue_block: BlockId,
    ) -> Result<(), LoweringError> {
        let saved_terminated = self.terminated;
        self.terminated = false;
        self.builder.position_at_end(start_block)?;
        self.push_scope();
        self.lower_statement(stmt)?;
        self.pop_scope();
        if !self.builder.block_has_terminator(start_block) {
            self.builder.emit_jump(continue_block)?;
        }
        self.terminated = saved_terminated;
        self.builder.position_at_end(continue_block)?;
        Ok(())
    }

    fn lower_while(&mut self, condition: &Expr, body: &Stmt) -> Result<(), LoweringError> {
        let cond_block = self.builder.append_block("while.cond");
        let loop_block = self.builder.append_block("while.body");
        let exit_block = self.builder.append_block("while.exit");
        let mut carried_names = HashSet::new();
        collect_expr_identifiers(condition, &mut carried_names);
        collect_assigned_variables(body, &mut carried_names);
        let mut loop_vars = Vec::new();
        for name in carried_names {
            if let Ok(value) = self.lookup(name.as_str()) {
                loop_vars.push((name, value));
            }
        }
        self.builder.emit_jump(cond_block)?;
        self.builder.position_at_end(cond_block)?;
        let mut phi_values = Vec::new();
        for (name, initial) in &loop_vars {
            let phi = self.builder.emit_value(
                IrOpcode::Phi,
                vec![*initial],
                TypeDescriptor::primitive(PrimitiveType::Any),
                Ownership::Owned,
                None,
            )?;
            self.assign(name.as_str(), phi)?;
            phi_values.push((name.clone(), phi));
        }
        let cond_value = self.lower_expression(condition)?;
        self.builder
            .emit_branch(cond_value, loop_block, exit_block)?;
        let saved_terminated = self.terminated;
        self.terminated = false;
        self.builder.position_at_end(loop_block)?;
        self.push_scope();
        self.lower_statement(body)?;
        self.pop_scope();
        if !self.builder.block_has_terminator(loop_block) {
            for (name, phi) in &phi_values {
                let current = self.lookup(name.as_str())?;
                self.append_phi_operand(cond_block, *phi, current)?;
            }
            self.builder.emit_jump(cond_block)?;
        }
        self.terminated = saved_terminated;
        self.builder.position_at_end(exit_block)?;
        for (name, phi) in phi_values {
            self.assign(name.as_str(), phi)?;
        }
        Ok(())
    }

    fn lower_loop(&mut self, body: &Stmt) -> Result<(), LoweringError> {
        let loop_block = self.builder.append_block("loop.body");
        let exit_block = self.builder.append_block("loop.exit");
        self.builder.emit_jump(loop_block)?;
        let saved_terminated = self.terminated;
        self.terminated = false;
        self.builder.position_at_end(loop_block)?;
        self.push_scope();
        self.lower_statement(body)?;
        self.pop_scope();
        if !self.builder.block_has_terminator(loop_block) {
            self.builder.emit_jump(loop_block)?;
        }
        self.terminated = saved_terminated;
        self.builder.position_at_end(exit_block)?;
        Ok(())
    }
}

fn flatten_literal_template(parts: &[StringPart]) -> Option<String> {
    let mut result = String::new();
    for part in parts {
        match part {
            StringPart::Literal(value) => result.push_str(value),
            StringPart::Expression(_) => return None,
        }
    }
    Some(result)
}

fn collect_expr_identifiers(expr: &Expr, names: &mut HashSet<String>) {
    match expr {
        Expr::Identifier { name, .. } => {
            names.insert(name.to_string());
        }
        Expr::Binary { left, right, .. } => {
            collect_expr_identifiers(left, names);
            collect_expr_identifiers(right, names);
        }
        Expr::Unary { operand, .. } => collect_expr_identifiers(operand, names),
        Expr::Assign { target, value, .. } => {
            if let AssignTarget::Variable(symbol) = target {
                names.insert(symbol.to_string());
            }
            collect_expr_identifiers(value, names);
        }
        Expr::Call { callee, args, .. } => {
            collect_expr_identifiers(callee, names);
            for arg in args {
                collect_expr_identifiers(arg, names);
            }
        }
        Expr::MethodCall { receiver, args, .. } => {
            collect_expr_identifiers(receiver, names);
            for arg in args {
                collect_expr_identifiers(arg, names);
            }
        }
        Expr::Member { object, .. } => collect_expr_identifiers(object, names),
        Expr::Index { object, index, .. } => {
            collect_expr_identifiers(object, names);
            collect_expr_identifiers(index, names);
        }
        Expr::List { elements, .. } => {
            for element in elements {
                collect_expr_identifiers(element, names);
            }
        }
        Expr::Range { start, end, .. } => {
            if let Some(expr) = start {
                collect_expr_identifiers(expr, names);
            }
            if let Some(expr) = end {
                collect_expr_identifiers(expr, names);
            }
        }
        Expr::Literal { value, .. } => match value {
            Literal::Array(items) => {
                for item in items {
                    collect_expr_identifiers(item, names);
                }
            }
            Literal::Object(fields) => {
                for (_, expr) in fields {
                    collect_expr_identifiers(expr, names);
                }
            }
            _ => {}
        },
        Expr::StringTemplate { parts, .. } | Expr::StringInterpolation { parts, .. } => {
            for part in parts {
                if let StringPart::Expression(expr) = part {
                    collect_expr_identifiers(expr, names);
                }
            }
        }
        _ => {}
    }
}

fn collect_expr_assignments(expr: &Expr, names: &mut HashSet<String>) {
    match expr {
        Expr::Assign { target, value, .. } => {
            if let AssignTarget::Variable(symbol) = target {
                names.insert(symbol.to_string());
            }
            collect_expr_assignments(value, names);
        }
        Expr::Binary { left, right, .. } => {
            collect_expr_assignments(left, names);
            collect_expr_assignments(right, names);
        }
        Expr::Unary { operand, .. } => collect_expr_assignments(operand, names),
        Expr::Call { callee, args, .. } => {
            collect_expr_assignments(callee, names);
            for arg in args {
                collect_expr_assignments(arg, names);
            }
        }
        Expr::MethodCall { receiver, args, .. } => {
            collect_expr_assignments(receiver, names);
            for arg in args {
                collect_expr_assignments(arg, names);
            }
        }
        Expr::Member { object, .. } => collect_expr_assignments(object, names),
        Expr::Index { object, index, .. } => {
            collect_expr_assignments(object, names);
            collect_expr_assignments(index, names);
        }
        Expr::List { elements, .. } => {
            for element in elements {
                collect_expr_assignments(element, names);
            }
        }
        Expr::Range { start, end, .. } => {
            if let Some(expr) = start {
                collect_expr_assignments(expr, names);
            }
            if let Some(expr) = end {
                collect_expr_assignments(expr, names);
            }
        }
        Expr::Literal { value, .. } => match value {
            Literal::Array(items) => {
                for item in items {
                    collect_expr_assignments(item, names);
                }
            }
            Literal::Object(fields) => {
                for (_, expr) in fields {
                    collect_expr_assignments(expr, names);
                }
            }
            _ => {}
        },
        Expr::StringTemplate { parts, .. } | Expr::StringInterpolation { parts, .. } => {
            for part in parts {
                if let StringPart::Expression(expr) = part {
                    collect_expr_assignments(expr, names);
                }
            }
        }
        _ => {}
    }
}

fn collect_assigned_variables(stmt: &Stmt, names: &mut HashSet<String>) {
    match stmt {
        Stmt::Expression { expr, .. } => collect_expr_assignments(expr, names),
        Stmt::Block { statements, .. } => {
            for stmt in statements {
                collect_assigned_variables(stmt, names);
            }
        }
        Stmt::If {
            condition,
            then_branch,
            else_branch,
            ..
        } => {
            collect_expr_assignments(condition, names);
            collect_assigned_variables(then_branch, names);
            if let Some(stmt) = else_branch {
                collect_assigned_variables(stmt, names);
            }
        }
        Stmt::While {
            condition, body, ..
        } => {
            collect_expr_assignments(condition, names);
            collect_assigned_variables(body, names);
        }
        Stmt::For { body, .. }
        | Stmt::ForIn { body, .. }
        | Stmt::ForOf { body, .. }
        | Stmt::Loop { body, .. } => collect_assigned_variables(body, names),
        Stmt::Return { value, .. } => {
            if let Some(expr) = value {
                collect_expr_assignments(expr, names);
            }
        }
        _ => {}
    }
}

//==============================================
// End of file
//==============================================
