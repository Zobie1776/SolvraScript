#![allow(dead_code)]

//==============================================
// File: solvra_script/ir/types.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: Duality Public License (DPL v1.0)
// Goal: Describe SolvraIR type metadata
// Objective: Provide descriptors for primitive/object/collection types and ownership models
//==============================================

use std::fmt;

/// Primitive scalar kinds tracked by SolvraIR.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PrimitiveType {
    Void,
    Bool,
    Int32,
    Int64,
    Float64,
    String,
    Object,
    Array,
    Function,
    Any,
}

impl fmt::Display for PrimitiveType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PrimitiveType::Void => f.write_str("void"),
            PrimitiveType::Bool => f.write_str("bool"),
            PrimitiveType::Int32 => f.write_str("i32"),
            PrimitiveType::Int64 => f.write_str("i64"),
            PrimitiveType::Float64 => f.write_str("f64"),
            PrimitiveType::String => f.write_str("string"),
            PrimitiveType::Object => f.write_str("object"),
            PrimitiveType::Array => f.write_str("array"),
            PrimitiveType::Function => f.write_str("function"),
            PrimitiveType::Any => f.write_str("any"),
        }
    }
}

/// Ownership semantics recorded for SSA values.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Ownership {
    Owned,
    Shared,
    Borrowed(BorrowKind),
}

/// Borrow flavour captured for references.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum BorrowKind {
    Immutable,
    Mutable,
}

/// Field metadata inside an [`ObjectSchema`].
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectField {
    pub name: String,
    pub ty: TypeDescriptor,
    pub optional: bool,
}

impl ObjectField {
    pub fn new(name: impl Into<String>, ty: TypeDescriptor) -> Self {
        Self {
            name: name.into(),
            ty,
            optional: false,
        }
    }

    pub fn optional(mut self) -> Self {
        self.optional = true;
        self
    }
}

/// Structural schema for Solvra objects.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectSchema {
    pub shape_id: u32,
    pub sealed: bool,
    pub fields: Vec<ObjectField>,
}

impl ObjectSchema {
    pub fn new(shape_id: u32) -> Self {
        Self {
            shape_id,
            sealed: false,
            fields: Vec::new(),
        }
    }

    pub fn sealed(mut self, sealed: bool) -> Self {
        self.sealed = sealed;
        self
    }

    pub fn with_fields(mut self, fields: Vec<ObjectField>) -> Self {
        self.fields = fields;
        self
    }
}

/// Rich type descriptor stored with every IR value.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeDescriptor {
    pub primitive: PrimitiveType,
    pub element: Option<Box<TypeDescriptor>>,
    pub tuple: Vec<TypeDescriptor>,
    pub object: Option<ObjectSchema>,
}

impl TypeDescriptor {
    pub const fn primitive(kind: PrimitiveType) -> Self {
        Self {
            primitive: kind,
            element: None,
            tuple: Vec::new(),
            object: None,
        }
    }

    pub fn array(element: TypeDescriptor) -> Self {
        Self {
            primitive: PrimitiveType::Array,
            element: Some(Box::new(element)),
            tuple: Vec::new(),
            object: None,
        }
    }

    pub fn tuple(elements: Vec<TypeDescriptor>) -> Self {
        Self {
            primitive: PrimitiveType::Object,
            element: None,
            tuple: elements,
            object: None,
        }
    }

    pub fn object(schema: ObjectSchema) -> Self {
        Self {
            primitive: PrimitiveType::Object,
            element: None,
            tuple: Vec::new(),
            object: Some(schema),
        }
    }
}

impl Default for TypeDescriptor {
    fn default() -> Self {
        Self::primitive(PrimitiveType::Any)
    }
}

impl fmt::Display for TypeDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(schema) = &self.object {
            write!(f, "object#{}", schema.shape_id)?;
            if !schema.fields.is_empty() {
                let parts: Vec<String> = schema
                    .fields
                    .iter()
                    .map(|field| {
                        if field.optional {
                            format!("{}?: {}", field.name, field.ty)
                        } else {
                            format!("{}: {}", field.name, field.ty)
                        }
                    })
                    .collect();
                write!(f, " {{{}}}", parts.join(", "))?;
            }
            return Ok(());
        }

        if !self.tuple.is_empty() {
            let parts: Vec<String> = self.tuple.iter().map(ToString::to_string).collect();
            return write!(f, "({})", parts.join(", "));
        }

        if let Some(element) = &self.element {
            return write!(f, "[{}]", element);
        }

        self.primitive.fmt(f)
    }
}

//==============================================
// End of file
//==============================================
