//=====================================================
// File: solvra_script/tests/cli_compile_tests.rs
// Author: Solvra Systems â€” Generated by Codex Agent
// License: DPL v1.0
// Goal: CLI compilation smoke tests
// Objective: Verify `solvra compile` produces .svc consumable by the VM runtime
//=====================================================

use std::fs;
use std::path::PathBuf;
use std::process::Command;

use bincode;
use solvra_core::vm::bytecode::VmBytecode;
use solvra_core::Value as RuntimeValue;
use solvrascript::vm::runtime::{RuntimeOptions, run_bytecode};
use tempfile::tempdir;

#[test]
fn cli_compiles_and_runs_svc() {
    let dir = tempdir().expect("tempdir");
    let source_path = dir.path().join("main.svs");
    let output_path = dir.path().join("main.svc");

    fs::write(
        &source_path,
        "function main() { return 2 + 3; }",
    )
    .expect("write source");

    let status = Command::new(env!("CARGO_BIN_EXE_solvrascript"))
        .args([
            "compile",
            source_path.to_str().unwrap(),
            "-o",
            output_path.to_str().unwrap(),
        ])
        .status()
        .expect("run compile");
    assert!(status.success(), "compile command failed");

    let bytes = fs::read(&output_path).expect("read svc");
    let bytecode: VmBytecode = bincode::deserialize(&bytes).expect("deserialize svc");
    let value =
        run_bytecode(std::sync::Arc::new(bytecode), RuntimeOptions::default()).expect("run svc");
    match value {
        RuntimeValue::Integer(v) => assert_eq!(v, 5),
        other => panic!("expected integer 5, got {other:?}"),
    }
}

//=====================================================
// End of file
//=====================================================
